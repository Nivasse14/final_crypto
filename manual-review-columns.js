#!/usr/bin/env node

// üîç Examen manuel des colonnes en lecture seule
// D√©termine lesquelles peuvent √™tre supprim√©es en toute s√©curit√©

import fs from 'fs';
import path from 'path';

// Colonnes identifi√©es comme √©tant en lecture seule
const READ_ONLY_COLUMNS = [
  'dune_mroi',
  'dune_invalids', 
  'pnl_total_volume_24h_usd',
  'pnl_avg_volume_24h_usd',
  'pnl_tokens_with_volume_data',
  'portfolio_total_volume_24h_usd',
  'portfolio_avg_volume_24h_usd',
  'portfolio_tokens_with_volume_data',
  'streak_wins_max_90d',
  'streak_losses_max_90d',
  'roi_50_to_200',
  'roi_0_to_50',
  'roi_total_trades',
  'roi_winning_trades',
  'roi_losing_trades',
  'roi_distribution_last_updated',
  'pnl_data_last_updated'
];

function manualReview() {
  console.log('üîç EXAMEN MANUEL DES COLONNES EN LECTURE SEULE');
  console.log('==============================================\n');
  
  const recommendations = {
    safeToRemove: [],
    reviewNeeded: [],
    keepForNow: []
  };
  
  // Analyser chaque colonne
  READ_ONLY_COLUMNS.forEach(column => {
    const analysis = analyzeColumn(column);
    
    if (analysis.recommendation === 'REMOVE') {
      recommendations.safeToRemove.push({column, reason: analysis.reason});
    } else if (analysis.recommendation === 'REVIEW') {
      recommendations.reviewNeeded.push({column, reason: analysis.reason});
    } else {
      recommendations.keepForNow.push({column, reason: analysis.reason});
    }
  });
  
  // Affichage des r√©sultats
  console.log('‚úÖ COLONNES S√õRES √Ä SUPPRIMER:');
  console.log('==============================');
  if (recommendations.safeToRemove.length === 0) {
    console.log('   Aucune colonne identifi√©e comme s√ªre √† supprimer sans review.');
  } else {
    recommendations.safeToRemove.forEach(({column, reason}) => {
      console.log(`   üóëÔ∏è  ${column}`);
      console.log(`       ‚Üí ${reason}`);
    });
  }
  console.log('');
  
  console.log('‚ö†Ô∏è  COLONNES N√âCESSITANT UNE REVIEW:');
  console.log('====================================');
  recommendations.reviewNeeded.forEach(({column, reason}) => {
    console.log(`   üîç ${column}`);
    console.log(`      ‚Üí ${reason}`);
  });
  console.log('');
  
  console.log('üìå COLONNES √Ä CONSERVER POUR L\'INSTANT:');
  console.log('=======================================');
  recommendations.keepForNow.forEach(({column, reason}) => {
    console.log(`   üì¶ ${column}`);
    console.log(`      ‚Üí ${reason}`);
  });
  console.log('');
  
  // Recherche de patterns suppl√©mentaires
  const additionalAnalysis = findAdditionalUnusedColumns();
  
  // G√©n√©rer les scripts SQL
  generateManualReviewSQL(recommendations, additionalAnalysis);
  
  return recommendations;
}

function analyzeColumn(column) {
  // Analyser chaque colonne sp√©cifiquement
  switch(column) {
    case 'dune_mroi':
      return {
        recommendation: 'REVIEW',
        reason: 'M√©trique Dune potentiellement obsol√®te, mais pourrait √™tre utilis√©e dans des rapports'
      };
      
    case 'dune_invalids':
      return {
        recommendation: 'REVIEW', 
        reason: 'Compteur d\'erreurs Dune - utile pour debugging mais peut √™tre obsol√®te'
      };
      
    case 'pnl_total_volume_24h_usd':
    case 'pnl_avg_volume_24h_usd':
    case 'pnl_tokens_with_volume_data':
      return {
        recommendation: 'REMOVE',
        reason: 'M√©triques de volume PnL - semblent √™tre des donn√©es calcul√©es non maintenues'
      };
      
    case 'portfolio_total_volume_24h_usd':
    case 'portfolio_avg_volume_24h_usd': 
    case 'portfolio_tokens_with_volume_data':
      return {
        recommendation: 'REMOVE',
        reason: 'M√©triques de volume portfolio - semblent √™tre des donn√©es calcul√©es non maintenues'
      };
      
    case 'streak_wins_max_90d':
    case 'streak_losses_max_90d':
      return {
        recommendation: 'REVIEW',
        reason: 'M√©triques de streaks - pourraient √™tre utilis√©es dans des analyses avanc√©es'
      };
      
    case 'roi_50_to_200':
    case 'roi_0_to_50':
    case 'roi_total_trades':
    case 'roi_winning_trades':
    case 'roi_losing_trades':
      return {
        recommendation: 'REMOVE',
        reason: 'Distribution ROI - donn√©es calcul√©es qui semblent obsol√®tes, non mises √† jour'
      };
      
    case 'roi_distribution_last_updated':
    case 'pnl_data_last_updated':
      return {
        recommendation: 'KEEP',
        reason: 'Timestamps de mise √† jour - utiles pour le debugging et la maintenance'
      };
      
    default:
      return {
        recommendation: 'REVIEW',
        reason: 'N√©cessite une analyse manuelle sp√©cifique'
      };
  }
}

function findAdditionalUnusedColumns() {
  console.log('üîç RECHERCHE DE COLONNES SUPPL√âMENTAIRES POTENTIELLEMENT INUTILES:');
  console.log('===================================================================\n');
  
  // Patterns de colonnes potentiellement obsol√®tes
  const suspiciousPatterns = [
    { pattern: /^dune_/, description: 'Colonnes Dune - API potentiellement obsol√®te' },
    { pattern: /.*_url$/, description: 'URLs externes - souvent non maintenues' },
    { pattern: /.*_link$/, description: 'Liens externes - souvent non maintenues' }
  ];
  
  const additionalCandidates = [];
  
  // Lire le fichier d'analyse pr√©c√©dent pour r√©cup√©rer toutes les colonnes
  let allColumns = [];
  try {
    const analysisData = JSON.parse(fs.readFileSync('targeted-column-analysis.json', 'utf8'));
    allColumns = analysisData.usedInSelects || [];
  } catch (err) {
    console.warn('Impossible de lire l\'analyse pr√©c√©dente');
    return [];
  }
  
  suspiciousPatterns.forEach(({pattern, description}) => {
    const matching = allColumns.filter(col => pattern.test(col));
    if (matching.length > 0) {
      console.log(`üìã ${description}:`);
      matching.forEach(col => {
        console.log(`   ‚ö†Ô∏è  ${col}`);
        additionalCandidates.push({
          column: col,
          pattern: pattern.source,
          reason: description
        });
      });
      console.log('');
    }
  });
  
  return additionalCandidates;
}

function generateManualReviewSQL(recommendations, additionalAnalysis) {
  console.log('üìù G√âN√âRATION DES SCRIPTS SQL:');
  console.log('==============================\n');
  
  // Script pour les colonnes s√ªres √† supprimer
  if (recommendations.safeToRemove.length > 0) {
    const safeColumns = recommendations.safeToRemove.map(r => r.column);
    const safeSQL = generateSafeDropSQL(safeColumns);
    fs.writeFileSync('drop-safe-columns.sql', safeSQL);
    console.log(`‚úÖ Script pour colonnes s√ªres: drop-safe-columns.sql (${safeColumns.length} colonnes)`);
  }
  
  // Script pour les colonnes n√©cessitant une review
  if (recommendations.reviewNeeded.length > 0) {
    const reviewColumns = recommendations.reviewNeeded.map(r => r.column);
    const reviewSQL = generateReviewSQL(reviewColumns, recommendations.reviewNeeded);
    fs.writeFileSync('drop-review-columns.sql', reviewSQL);
    console.log(`‚ö†Ô∏è  Script pour review: drop-review-columns.sql (${reviewColumns.length} colonnes)`);
  }
  
  // Script d'analyse des donn√©es
  const analysisSQL = generateDataAnalysisSQL(recommendations);
  fs.writeFileSync('analyze-column-data.sql', analysisSQL);
  console.log(`üîç Script d'analyse des donn√©es: analyze-column-data.sql`);
  
  console.log('\nüìã INSTRUCTIONS:');
  console.log('================');
  console.log('1. Ex√©cutez d\'abord analyze-column-data.sql pour voir les donn√©es');
  console.log('2. Si les donn√©es sont vides/obsol√®tes, utilisez drop-safe-columns.sql');
  console.log('3. Examinez manuellement drop-review-columns.sql avant ex√©cution');
  console.log('4. Testez apr√®s chaque suppression');
}

function generateSafeDropSQL(columns) {
  let sql = '-- Script pour supprimer les colonnes identifi√©es comme s√ªres\n';
  sql += `-- Date: ${new Date().toISOString()}\n`;
  sql += `-- Colonnes: ${columns.length}\n`;
  sql += '-- ‚ö†Ô∏è  SAUVEGARDE OBLIGATOIRE !\n\n';
  
  sql += '-- √âTAPE 1: Sauvegarde\n';
  sql += 'CREATE TABLE wallet_registry_safe_backup AS SELECT * FROM wallet_registry;\n\n';
  
  sql += '-- √âTAPE 2: Suppression des colonnes s√ªres\n';
  columns.forEach(column => {
    sql += `-- ${column} - M√©trique de volume/ROI obsol√®te\n`;
    sql += `ALTER TABLE wallet_registry DROP COLUMN IF EXISTS ${column};\n`;
  });
  
  sql += '\n-- √âTAPE 3: V√©rification\n';
  sql += 'SELECT COUNT(*) as colonnes_restantes FROM information_schema.columns WHERE table_name = \'wallet_registry\';\n';
  
  return sql;
}

function generateReviewSQL(columns, details) {
  let sql = '-- Script pour supprimer les colonnes n√©cessitant une review\n';
  sql += '-- ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATTENTION: REVIEW MANUELLE REQUISE AVANT EX√âCUTION !\n';
  sql += `-- Date: ${new Date().toISOString()}\n\n`;
  
  sql += '-- √âTAPE 1: Examiner les donn√©es existantes\n';
  columns.forEach(column => {
    const detail = details.find(d => d.column === column);
    sql += `-- ${column}: ${detail?.reason || 'Review n√©cessaire'}\n`;
    sql += `SELECT '${column}' as colonne, COUNT(*) as total_rows, COUNT(${column}) as non_null_rows, `;
    sql += `COUNT(DISTINCT ${column}) as distinct_values FROM wallet_registry;\n`;
  });
  
  sql += '\n-- √âTAPE 2: Si les donn√©es sont obsol√®tes, d√©commentez les lignes suivantes\n';
  columns.forEach(column => {
    sql += `-- ALTER TABLE wallet_registry DROP COLUMN IF EXISTS ${column};\n`;
  });
  
  return sql;
}

function generateDataAnalysisSQL(recommendations) {
  const allColumns = [
    ...recommendations.safeToRemove.map(r => r.column),
    ...recommendations.reviewNeeded.map(r => r.column)
  ];
  
  let sql = '-- Script d\'analyse des donn√©es pour les colonnes candidates √† la suppression\n';
  sql += `-- Date: ${new Date().toISOString()}\n\n`;
  
  sql += '-- Vue d\'ensemble des donn√©es\n';
  sql += 'SELECT COUNT(*) as total_wallets FROM wallet_registry;\n\n';
  
  sql += '-- Analyse de chaque colonne candidate\n';
  allColumns.forEach(column => {
    sql += `-- ${column}\n`;
    sql += `SELECT \n`;
    sql += `  '${column}' as colonne,\n`;
    sql += `  COUNT(*) as total_rows,\n`;
    sql += `  COUNT(${column}) as non_null_count,\n`;
    sql += `  COUNT(DISTINCT ${column}) as distinct_values,\n`;
    sql += `  ROUND(COUNT(${column})::numeric / COUNT(*) * 100, 2) as fill_percentage\n`;
    sql += `FROM wallet_registry;\n\n`;
  });
  
  sql += '-- Derni√®re activit√© sur ces colonnes\n';
  sql += 'SELECT \n';
  sql += '  MAX(updated_at) as derniere_mise_a_jour,\n';
  sql += '  COUNT(*) as wallets_avec_donnees\n';
  sql += 'FROM wallet_registry \n';
  sql += 'WHERE (\n';
  sql += allColumns.map(col => `  ${col} IS NOT NULL`).join(' OR\n');
  sql += '\n);\n';
  
  return sql;
}

// Ex√©cution
const results = manualReview();

// Sauvegarder les r√©sultats
const output = {
  timestamp: new Date().toISOString(),
  readOnlyColumns: READ_ONLY_COLUMNS,
  recommendations: results,
  summary: {
    safeToRemove: results.safeToRemove.length,
    reviewNeeded: results.reviewNeeded.length,
    keepForNow: results.keepForNow.length
  }
};

fs.writeFileSync('manual-review-results.json', JSON.stringify(output, null, 2));
console.log('\nüíæ R√©sultats de la review sauvegard√©s: manual-review-results.json');