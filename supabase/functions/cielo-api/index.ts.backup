// @ts-ignore: Deno import
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
// @ts-ignore: Deno import  
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// Configuration API Cielo
const CIELO_CONFIG = {
  baseUrl: 'https://feed-api.cielo.finance/v1',
  headers: {
    'Api-Key': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0aW1lc3RhbXAiOjE3NTM1NTAxNjV9.auH6IR4uqg8NlkhyT82sEpav6mvvvRnMMf6hjOnSd0w',
    'Authorization': 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZGRyZXNzIjoiNkhQRVQ3UkxZZHZ6Z0hTVHVhRWNWbTRoTTV3VkxYa3Z2OTVOWm4yYW0xNGkiLCJpc3MiOiJodHRwczovL2FwaS51bml3aGFsZXMuaW8vIiwic3ViIjoidXNlciIsInBsYW5iOiJiYXNpYyIsImJhbGFuY2UiOjAsImlhdCI6MTc1MzU1MDAxNywiZXhwIjoxNzUzNTYwODE3fQ.t99299sp1pEKJnr8B61GLdj4e6f3bs29uM4xCLUpqVE',
    'Content-Type': 'application/json'
  }
};

// Configuration Supabase pour la persistance
const SUPABASE_FUNCTION_URL = 'https://xkndddxqqlxqknbqtefv.supabase.co/functions/v1';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhrbmRkZHhxcWx4cWtuYnF0ZWZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMTY3MTEsImV4cCI6MjA2ODU5MjcxMX0.1JfLmuXhKZLhSpIVkoubfaaE9M1jAANoPjKcXZTgPgU';

// Configuration API Geckoterminal
const GECKOTERMINAL_CONFIG = {
  baseUrl: 'https://api.geckoterminal.com/api/v2',
  baseUrlP1: 'https://app.geckoterminal.com/api/p1', // API p1 pour donn√©es enrichies
  headers: {
    'Accept': 'application/json',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
  }
};

// Cache pour √©viter les requ√™tes r√©p√©t√©es
const cache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

/**
 * Fonction utilitaire pour faire des requ√™tes √† l'API Cielo
 */
async function cieloRequest(endpoint: string): Promise<any> {
  const fullUrl = `${CIELO_CONFIG.baseUrl}${endpoint}`;
  
  try {
    console.log(`üåê [CIELO REQUEST] ${fullUrl}`);
    console.log(`üì§ [CIELO HEADERS]`, JSON.stringify(CIELO_CONFIG.headers, null, 2));
    
    const startTime = Date.now();
    
    const response = await fetch(fullUrl, {
      method: 'GET',
      headers: CIELO_CONFIG.headers
    });

    const duration = Date.now() - startTime;
    console.log(`‚è±Ô∏è [CIELO RESPONSE] ${response.status} ${response.statusText} (${duration}ms)`);

    if (!response.ok) {
      console.error(`‚ùå [CIELO ERROR] HTTP ${response.status}: ${response.statusText}`);
      console.error(`üîó [CIELO ERROR URL] ${fullUrl}`);
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log(`üì• [CIELO RESPONSE DATA] Taille: ${JSON.stringify(data).length} caract√®res`);
    console.log(`üîç [CIELO RESPONSE STRUCTURE]:`, Object.keys(data));
    
    // Log du premier niveau de structure pour le debug
    if (data.data) {
      console.log(`üìä [CIELO DATA STRUCTURE]:`, Object.keys(data.data));
      
      // Cas sp√©cifique pour les tokens PnL
      if (data.data.tokens && Array.isArray(data.data.tokens)) {
        console.log(`ü™ô [CIELO TOKENS] ${data.data.tokens.length} tokens trouv√©s`);
        if (data.data.tokens.length > 0) {
          console.log(`üîç [CIELO FIRST TOKEN]:`, Object.keys(data.data.tokens[0]));
        }
      }
      
      // Cas sp√©cifique pour le portfolio
      if (data.data.portfolio && Array.isArray(data.data.portfolio)) {
        console.log(`üìã [CIELO PORTFOLIO] ${data.data.portfolio.length} tokens dans le portfolio`);
        if (data.data.portfolio.length > 0) {
          console.log(`üîç [CIELO FIRST PORTFOLIO TOKEN]:`, Object.keys(data.data.portfolio[0]));
        }
      }
    }
    
    return data;
  } catch (error) {
    console.error(`üí• [CIELO ERROR] ${fullUrl}:`, error.message);
    throw error;
  }
}

/**
 * Fonction utilitaire pour faire des requ√™tes √† l'API Geckoterminal
 */
async function geckoterminalRequest(endpoint: string): Promise<any> {
  const fullUrl = `${GECKOTERMINAL_CONFIG.baseUrl}${endpoint}`;
  
  try {
    console.log(`ü¶é [GECKO REQUEST] ${fullUrl}`);
    console.log(`üì§ [GECKO HEADERS]`, JSON.stringify(GECKOTERMINAL_CONFIG.headers, null, 2));
    
    const startTime = Date.now();
    
    const response = await fetch(fullUrl, {
      method: 'GET',
      headers: GECKOTERMINAL_CONFIG.headers
    });

    const duration = Date.now() - startTime;
    console.log(`‚è±Ô∏è [GECKO RESPONSE] ${response.status} ${response.statusText} (${duration}ms)`);

    if (!response.ok) {
      console.log(`‚ö†Ô∏è [GECKO WARNING] HTTP ${response.status}: ${response.statusText}`);
      console.log(`üîó [GECKO WARNING URL] ${fullUrl}`);
      
      // G√©rer les erreurs 404 sp√©cialement (token/pool non trouv√©)
      if (response.status === 404) {
        console.log(`üîç [GECKO 404] Token/Pool non trouv√© sur Geckoterminal`);
        return { data: null, error: 'not_found' };
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log(`üì• [GECKO RESPONSE DATA] Taille: ${JSON.stringify(data).length} caract√®res`);
    console.log(`üîç [GECKO RESPONSE STRUCTURE]:`, Object.keys(data));
    
    return data;
  } catch (error) {
    // Ne pas logger les erreurs 404 comme des erreurs
    if (!error.message.includes('404')) {
      console.error(`üí• [GECKO ERROR] ${fullUrl}:`, error.message);
    }
    throw error;
  }
}

/**
 * Fonction utilitaire pour faire des requ√™tes √† l'API Geckoterminal P1 (donn√©es enrichies)
 */
async function geckoterminalP1Request(endpoint: string): Promise<any> {
  const fullUrl = `${GECKOTERMINAL_CONFIG.baseUrlP1}${endpoint}`;
  
  try {
    console.log(`ü¶é [GECKO P1 REQUEST] ${fullUrl}`);
    console.log(`üì§ [GECKO P1 HEADERS]`, JSON.stringify(GECKOTERMINAL_CONFIG.headers, null, 2));
    
    const startTime = Date.now();
    
    const response = await fetch(fullUrl, {
      method: 'GET',
      headers: GECKOTERMINAL_CONFIG.headers
    });

    const duration = Date.now() - startTime;
    console.log(`‚è±Ô∏è [GECKO P1 RESPONSE] ${response.status} ${response.statusText} (${duration}ms)`);

    if (!response.ok) {
      console.log(`‚ö†Ô∏è [GECKO P1 WARNING] HTTP ${response.status}: ${response.statusText}`);
      console.log(`üîó [GECKO P1 WARNING URL] ${fullUrl}`);
      
      // G√©rer les erreurs 404 sp√©cialement (token/pool non trouv√©)
      if (response.status === 404) {
        console.log(`üîç [GECKO P1 404] Token/Pool non trouv√© sur Geckoterminal P1`);
        return { data: null, error: 'not_found' };
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log(`üì• [GECKO P1 RESPONSE DATA] Taille: ${JSON.stringify(data).length} caract√®res`);
    console.log(`üîç [GECKO P1 RESPONSE STRUCTURE]:`, Object.keys(data));
    
    return data;
  } catch (error) {
    // Ne pas logger les erreurs 404 comme des erreurs
    if (!error.message.includes('404')) {
      console.error(`üí• [GECKO P1 ERROR] ${fullUrl}:`, error.message);
    }
    throw error;
  }
}

/**
 * Enrichir un token avec les donn√©es d√©taill√©es du pool P1 si l'adresse du pool est connue
 */
async function enrichTokenWithGeckoP1Pool(token: any, poolAddress: string, network: string = 'solana'): Promise<any> {
  console.log(`üöÄ [GECKO P1 POOL] Enrichissement avanc√© pour ${token.token_symbol || 'Unknown'} via pool ${poolAddress}`);
  
  const cacheKey = `gecko_p1_pool_${network}_${poolAddress}`;
  const cachedData = cache.get(cacheKey);
  
  if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_DURATION) {
    console.log(`üì¶ [GECKO P1 CACHE HIT] ${poolAddress}`);
    return { ...token, ...cachedData.data };
  }

  try {
    // Utiliser l'API P1 avec tous les param√®tres d'inclusion pour le maximum de donn√©es
    const p1Endpoint = `/${network}/pools/${poolAddress}?include=dex%2Cdex.network.explorers%2Cdex_link_services%2Cnetwork_link_services%2Cpairs%2Ctoken_link_services%2Ctokens.token_security_metric%2Ctokens.tags%2Cpool_locked_liquidities&base_token=0`;
    
    console.log(`üåê [GECKO P1] Appel API P1 pour pool ${poolAddress}`);
    const p1Data = await geckoterminalP1Request(p1Endpoint);
    
    if (p1Data && p1Data.data && p1Data.data.attributes) {
      const poolAttrs = p1Data.data.attributes;
      
      console.log(`üìä [GECKO P1] Pool enrichi - Prix: $${poolAttrs.price_in_usd}, FDV: $${poolAttrs.fully_diluted_valuation}`);
      
      // Trouver le token correspondant dans les donn√©es incluses
      let tokenData: any = null;
      if (p1Data.included && Array.isArray(p1Data.included)) {
        tokenData = p1Data.included.find((item: any) => 
          item.type === 'token' && 
          item.attributes?.address === token.token_address
        );
      }
      
      // Enrichissement maximal avec toutes les donn√©es P1
      const enrichedData: any = {
        // Flags d'enrichissement
        gecko_enriched: true,
        gecko_data_source: 'pools_api_p1_advanced',
        gecko_updated_at: new Date().toISOString(),
        
        // Identifiants
        gecko_pool_id: p1Data.data.id,
        gecko_pool_address: poolAddress,
        gecko_name: tokenData?.attributes?.name || poolAttrs.name || token.token_symbol,
        gecko_symbol: tokenData?.attributes?.symbol || token.token_symbol,
        
        // Prix et valeurs principales (P1 plus pr√©cis)
        price_usd: poolAttrs.price_in_usd ? parseFloat(poolAttrs.price_in_usd) : null,
        market_cap_usd: tokenData?.attributes?.market_cap_in_usd ? parseFloat(tokenData.attributes.market_cap_in_usd) : null,
        fdv_usd: poolAttrs.fully_diluted_valuation ? parseFloat(poolAttrs.fully_diluted_valuation) : null,
        liquidity_usd: poolAttrs.reserve_in_usd ? parseFloat(poolAttrs.reserve_in_usd) : null,
        
        // Volume et trading (P1)
        from_volume_in_usd: poolAttrs.from_volume_in_usd ? parseFloat(poolAttrs.from_volume_in_usd) : null,
        to_volume_in_usd: poolAttrs.to_volume_in_usd ? parseFloat(poolAttrs.to_volume_in_usd) : null,
        swap_count_24h: poolAttrs.swap_count_24h || null,
        
        // Variations de prix (P1 structure diff√©rente)
        price_change_percentage_1h: poolAttrs.price_percent_changes?.h1 ? parseFloat(poolAttrs.price_percent_changes.h1) : null,
        price_change_percentage_6h: poolAttrs.price_percent_changes?.h6 ? parseFloat(poolAttrs.price_percent_changes.h6) : null,
        price_change_percentage_24h: poolAttrs.price_percent_changes?.h24 ? parseFloat(poolAttrs.price_percent_changes.h24) : null,
        
        // Donn√©es avanc√©es P1
        gt_score: poolAttrs.gt_score || null,
        gt_score_details: poolAttrs.gt_score_details || null,
        pool_fee: poolAttrs.pool_fee || null,
        is_nsfw: poolAttrs.is_nsfw || false,
        reserve_threshold_met: poolAttrs.reserve_threshold_met || false,
        security_indicators: poolAttrs.security_indicators || null,
        
        // Informations du pool
        pool_address: poolAttrs.address || poolAddress,
        pool_created_at: poolAttrs.pool_created_at || null,
        latest_swap_timestamp: poolAttrs.latest_swap_timestamp || null,
        
        // Donn√©es du token si disponibles
        gecko_token_image_url: tokenData?.attributes?.image_url || null,
        gecko_banner_image_url: tokenData?.attributes?.banner_image_url || null,
        gecko_description: tokenData?.attributes?.description || null,
        gecko_circulating_supply: tokenData?.attributes?.circulating_supply || null,
        gecko_decimals: tokenData?.attributes?.decimals || null,
        gecko_coingecko_id: tokenData?.attributes?.cg_coin_id || null,
        gecko_on_coingecko: tokenData?.attributes?.on_coingecko || false,
        gecko_on_pump_fun: tokenData?.attributes?.on_pump_fun || false,
        gecko_supports_bubblemaps: tokenData?.attributes?.supports_bubblemaps || false,
        gecko_links: tokenData?.attributes?.links || null,
        
        // Adresses et tokens
        base_token_address: token.token_address,
        token_reserves: poolAttrs.token_reserves || null,
        token_value_data: poolAttrs.token_value_data || null,
        token_weightages: poolAttrs.token_weightages || null
      };
      
      // Mettre en cache
      cache.set(cacheKey, {
        data: enrichedData,
        timestamp: Date.now()
      });
      
      console.log(`‚úÖ [GECKO P1 ENRICHED] ${token.token_address} - Prix: $${poolAttrs.price_in_usd}, FDV: $${poolAttrs.fully_diluted_valuation} - Source: pools_api_p1`);
      return { ...token, ...enrichedData };
      
    } else {
      console.log(`‚ö†Ô∏è [GECKO P1] Aucune donn√©es P1 pour pool ${poolAddress}`);
      return { ...token, gecko_enriched: false };
    }
    
  } catch (error) {
    console.log(`‚ö†Ô∏è [GECKO P1 SKIP] Pool ${poolAddress}: ${error.message}`);
    return { ...token, gecko_enriched: false };
  }
}
/**
 * Enrichir les donn√©es avec Geckoterminal (prix, market cap, etc.)
 * APPROCHE SIMPLIFI√âE ET ROBUSTE:
 * 1. Essayer d'abord l'API directe du token
 * 2. En fallback, utiliser l'API des pools
 */
async function enrichTokenWithGecko(token: any, network: string = 'solana'): Promise<any> {
  console.log(`üîÑ [GECKO START] D√©but enrichissement pour ${token.token_symbol || 'Unknown'} (${token.token_address})`);
  
  if (!token.token_address) {
    console.log(`‚ö†Ô∏è [GECKO] Pas d'adresse token pour ${token.token_symbol || 'Unknown'}`);
    return { ...token, gecko_enriched: false };
  }

  const cacheKey = `gecko_enriched_${network}_${token.token_address}`;
  const cachedData = cache.get(cacheKey);
  
  if (cachedData && (Date.now() - cachedData.timestamp) < CACHE_DURATION) {
    console.log(`üì¶ [GECKO CACHE HIT] ${token.token_address}`);
    return { ...token, ...cachedData.data };
  }

  try {
    // M√âTHODE 1 : API directe du token (plus simple et fiable)
    console.log(`üåê [GECKO METHOD 1] API directe token pour ${token.token_address}`);
    const tokenEndpoint = `/networks/${network}/tokens/${token.token_address}`;
    
    let tokenData;
    try {
      tokenData = await geckoterminalRequest(tokenEndpoint);
      
      if (tokenData && tokenData.data && tokenData.data.attributes) {
        const attrs = tokenData.data.attributes;
        console.log(`‚úÖ [GECKO METHOD 1] Token trouv√© - Prix: $${attrs.price_usd}, FDV: $${attrs.fdv_usd}`);
        
        // Construire les donn√©es enrichies depuis l'API directe
        const enrichedData = {
          ...token,
          gecko_enriched: true,
          gecko_data_source: 'token_api_direct',
          gecko_updated_at: new Date().toISOString(),
          gecko_enrichment_method: 'token_api_v2',
          
          // Donn√©es de prix et march√©
          gecko_price_usd: attrs.price_usd ? parseFloat(attrs.price_usd) : null,
          price_usd: attrs.price_usd ? parseFloat(attrs.price_usd) : null,
          gecko_fdv_usd: attrs.fdv_usd ? parseFloat(attrs.fdv_usd) : null,
          fdv_usd: attrs.fdv_usd ? parseFloat(attrs.fdv_usd) : null,
          gecko_market_cap_usd: attrs.market_cap_usd ? parseFloat(attrs.market_cap_usd) : null,
          market_cap_usd: attrs.market_cap_usd ? parseFloat(attrs.market_cap_usd) : null,
          gecko_volume_24h_usd: attrs.volume_usd?.h24 ? parseFloat(attrs.volume_usd.h24) : null,
          volume_24h_usd: attrs.volume_usd?.h24 ? parseFloat(attrs.volume_usd.h24) : null,
          gecko_liquidity_usd: attrs.total_reserve_in_usd ? parseFloat(attrs.total_reserve_in_usd) : null,
          liquidity_usd: attrs.total_reserve_in_usd ? parseFloat(attrs.total_reserve_in_usd) : null,
          
          // M√©tadonn√©es token
          gecko_name: attrs.name || token.token_name,
          gecko_symbol: attrs.symbol || token.token_symbol,
          gecko_decimals: attrs.decimals,
          gecko_image_url: attrs.image_url,
          gecko_coingecko_id: attrs.coingecko_coin_id,
          gecko_total_supply: attrs.total_supply,
          
          // ID et liens
          gecko_id: tokenData.data.id,
          gecko_token_address: attrs.address
        };
        
        // Mettre en cache et retourner
        cache.set(cacheKey, {
          data: enrichedData,
          timestamp: Date.now()
        });
        
        console.log(`‚úÖ [GECKO SUCCESS] Token enrichi avec API directe - Prix: $${enrichedData.gecko_price_usd}`);
        return enrichedData;
      }
    } catch (tokenError) {
      console.log(`‚ö†Ô∏è [GECKO METHOD 1] API token failed: ${tokenError.message}`);
    }
    
    // M√âTHODE 2 : FALLBACK via API des pools
    console.log(`üåê [GECKO METHOD 2] Fallback pools pour ${token.token_address}`);
    const poolsEndpoint = `/networks/${network}/tokens/${token.token_address}/pools?include=dex,base_token&page=1&limit=3`;
    
    let poolsData;
    try {
      poolsData = await geckoterminalRequest(poolsEndpoint);
      
      if (poolsData && poolsData.data && Array.isArray(poolsData.data) && poolsData.data.length > 0) {
        const mainPool = poolsData.data[0];
        const poolAttrs = mainPool.attributes;
        console.log(`‚úÖ [GECKO METHOD 2] Pool trouv√© - Prix: $${poolAttrs.base_token_price_usd}`);
        
        // Construire les donn√©es enrichies depuis les pools
        const enrichedData = {
          ...token,
          gecko_enriched: true,
          gecko_data_source: 'pools_api_v2',
          gecko_updated_at: new Date().toISOString(),
          gecko_enrichment_method: 'pools_api_v2',
          
          // Donn√©es de prix depuis le pool
          gecko_price_usd: poolAttrs.base_token_price_usd ? parseFloat(poolAttrs.base_token_price_usd) : null,
          price_usd: poolAttrs.base_token_price_usd ? parseFloat(poolAttrs.base_token_price_usd) : null,
          gecko_fdv_usd: poolAttrs.fdv_usd ? parseFloat(poolAttrs.fdv_usd) : null,
          fdv_usd: poolAttrs.fdv_usd ? parseFloat(poolAttrs.fdv_usd) : null,
          gecko_market_cap_usd: poolAttrs.market_cap_usd ? parseFloat(poolAttrs.market_cap_usd) : null,
          market_cap_usd: poolAttrs.market_cap_usd ? parseFloat(poolAttrs.market_cap_usd) : null,
          gecko_liquidity_usd: poolAttrs.reserve_in_usd ? parseFloat(poolAttrs.reserve_in_usd) : null,
          liquidity_usd: poolAttrs.reserve_in_usd ? parseFloat(poolAttrs.reserve_in_usd) : null,
          gecko_volume_24h_usd: poolAttrs.volume_usd?.h24 ? parseFloat(poolAttrs.volume_usd.h24) : null,
          volume_24h_usd: poolAttrs.volume_usd?.h24 ? parseFloat(poolAttrs.volume_usd.h24) : null,
          
          // M√©tadonn√©es pool
          gecko_pool_address: poolAttrs.address,
          gecko_pool_id: mainPool.id,
          gecko_pool_name: poolAttrs.name,
          
          // ID
          gecko_id: mainPool.id
        };
        
        // Mettre en cache et retourner
        cache.set(cacheKey, {
          data: enrichedData,
          timestamp: Date.now()
        });
        
        console.log(`‚úÖ [GECKO SUCCESS] Token enrichi avec pools - Prix: $${enrichedData.gecko_price_usd}`);
        return enrichedData;
      }
    } catch (poolsError) {
      console.log(`‚ö†Ô∏è [GECKO METHOD 2] Pools failed: ${poolsError.message}`);
    }
    
    // Si tout √©choue
    console.log(`‚ùå [GECKO FAILED] Aucune m√©thode n'a fonctionn√© pour ${token.token_address}`);
    return { ...token, gecko_enriched: false };
    
  } catch (error) {
    console.error(`üí• [GECKO ERROR] Erreur inattendue pour ${token.token_address}:`, error.message);
    return { ...token, gecko_enriched: false };
  }
}

/**
 * Calculer les statistiques de p√©riode (7j, all time)
 */
            const finalEnrichedData = {
              ...enrichedWithP1,
              gecko_pool_address: cleanPoolAddress, // Stocker l'adresse du pool utilis√©e
              gecko_pool_id: mainPool.id, // Stocker l'ID complet du pool
              gecko_enrichment_method: 'v2_pool_discovery_then_p1_enrichment'
            };
            
            // Mettre en cache
            cache.set(cacheKey, {
              data: finalEnrichedData,
              timestamp: Date.now()
            });
            
            return finalEnrichedData;
          } else {
            console.log(`‚ö†Ô∏è [GECKO] P1 enrichissement failed, fallback to V2 pools data`);
            // Continuer vers le fallback V2 ci-dessous
          }
        } catch (p1Error) {
          console.log(`‚ö†Ô∏è [GECKO] P1 API error: ${p1Error.message}, fallback to V2`);
          // Continuer vers le fallback V2 ci-dessous
        }
      }
      
      // FALLBACK V2 : Utiliser les donn√©es de pools V2 si P1 non disponible
      const poolAttrs = mainPool.attributes;
      console.log(`üìä [GECKO V2 FALLBACK] Pool trouv√© - Prix: $${poolAttrs.base_token_price_usd}, Liquidit√©: $${poolAttrs.reserve_in_usd}`);
      
      // Enrichissement V2 (version actuelle)
      const enrichedData: any = {
        // Flags d'enrichissement
        gecko_enriched: true,
        gecko_data_source: 'pools_api_v2_fallback',
        gecko_updated_at: new Date().toISOString(),
        gecko_enrichment_method: 'v2_pools_only',
        
        // Identifiants
        gecko_id: mainPool.id,
        gecko_name: poolAttrs.name || token.token_symbol,
        gecko_symbol: poolAttrs.base_token_symbol || token.token_symbol,
        gecko_pool_address: mainPool.attributes?.address || null, // Stocker l'adresse du pool
        gecko_pool_id: mainPool.id,
        
        // Prix et valeurs principales
        price_usd: poolAttrs.base_token_price_usd ? parseFloat(poolAttrs.base_token_price_usd) : null,
        market_cap_usd: poolAttrs.market_cap_usd ? parseFloat(poolAttrs.market_cap_usd) : null,
        fdv_usd: poolAttrs.fdv_usd ? parseFloat(poolAttrs.fdv_usd) : null,
        liquidity_usd: poolAttrs.reserve_in_usd ? parseFloat(poolAttrs.reserve_in_usd) : null,
        
        // Volume sur diff√©rentes p√©riodes
        volume_24h_usd: poolAttrs.volume_usd?.h24 ? parseFloat(poolAttrs.volume_usd.h24) : null,
        volume_1h_usd: poolAttrs.volume_usd?.h1 ? parseFloat(poolAttrs.volume_usd.h1) : null,
        volume_6h_usd: poolAttrs.volume_usd?.h6 ? parseFloat(poolAttrs.volume_usd.h6) : null,
        
        // Variations de prix
        price_change_percentage_1h: poolAttrs.price_change_percentage?.h1 ? parseFloat(poolAttrs.price_change_percentage.h1) : null,
        price_change_percentage_6h: poolAttrs.price_change_percentage?.h6 ? parseFloat(poolAttrs.price_change_percentage.h6) : null,
        price_change_percentage_24h: poolAttrs.price_change_percentage?.h24 ? parseFloat(poolAttrs.price_change_percentage.h24) : null,
        
        // Donn√©es de trading/transactions
        transactions_24h_buys: poolAttrs.transactions?.h24?.buys || null,
        transactions_24h_sells: poolAttrs.transactions?.h24?.sells || null,
        transactions_1h_buys: poolAttrs.transactions?.h1?.buys || null,
        transactions_1h_sells: poolAttrs.transactions?.h1?.sells || null,
        
        // Informations du pool
        pool_address: poolAttrs.address || null,
        dex: mainPool.relationships?.dex?.data?.id || null,
        base_token_address: poolAttrs.base_token_address || token.token_address,
        quote_token_address: poolAttrs.quote_token_address || null,
        pool_created_at: poolAttrs.pool_created_at || null,
        
        // M√©tadonn√©es suppl√©mentaires si disponibles
        gecko_total_supply: poolAttrs.total_supply || null,
        gecko_circulating_supply: poolAttrs.circulating_supply || null,
        gecko_max_supply: poolAttrs.max_supply || null,
        gecko_token_image_url: null
      };
      
      // Ajouter les donn√©es du token inclus si disponibles
      if (poolsData.included) {
        const baseTokenData = poolsData.included.find((item: any) => 
          item.type === 'token' && item.attributes?.address === token.token_address
        );
        
        if (baseTokenData) {
          enrichedData.gecko_name = baseTokenData.attributes.name || enrichedData.gecko_name;
          enrichedData.gecko_symbol = baseTokenData.attributes.symbol || enrichedData.gecko_symbol;
          enrichedData.gecko_token_image_url = baseTokenData.attributes.image_url || null;
          enrichedData.gecko_total_supply = baseTokenData.attributes.total_supply || enrichedData.gecko_total_supply;
        }
      }
      
      // Mettre en cache
      cache.set(cacheKey, {
        data: enrichedData,
        timestamp: Date.now()
      });
      
      console.log(`‚úÖ [GECKO V2 ENRICHED] ${token.token_address} - Prix: $${poolAttrs.base_token_price_usd} - Source: pools_api_v2`);
      return { ...token, ...enrichedData };
      
    } else {
      console.log(`‚ö†Ô∏è [GECKO] Aucun pool trouv√© pour ${token.token_address}, fallback vers API tokens`);
      
      // FALLBACK FINAL : Utiliser l'API tokens classique V2
      const tokenEndpoint = `/networks/${network}/tokens/${token.token_address}`;
      const tokenData = await geckoterminalRequest(tokenEndpoint);
      
      if (tokenData && tokenData.data && tokenData.data.attributes) {
        const attrs = tokenData.data.attributes;
        console.log(`üìä [GECKO TOKEN FALLBACK] Prix: ${attrs.price_usd}, MarketCap: ${attrs.market_cap_usd}`);
        
        const enrichedData = {
          // Flags d'enrichissement
          gecko_enriched: true,
          gecko_data_source: 'tokens_api_v2_fallback',
          gecko_updated_at: new Date().toISOString(),
          gecko_enrichment_method: 'v2_tokens_only',
          
          // Identifiants
          gecko_id: tokenData.data.id,
          gecko_name: attrs.name || token.token_symbol,
          gecko_symbol: attrs.symbol || token.token_symbol,
          
          // Prix et valeurs
          price_usd: attrs.price_usd ? parseFloat(attrs.price_usd) : null,
          market_cap_usd: attrs.market_cap_usd ? parseFloat(attrs.market_cap_usd) : null,
          fdv_usd: attrs.fdv_usd ? parseFloat(attrs.fdv_usd) : null,
          
          // Volume
          volume_24h_usd: attrs.volume_usd?.h24 ? parseFloat(attrs.volume_usd.h24) : null,
          volume_1h_usd: attrs.volume_usd?.h1 ? parseFloat(attrs.volume_usd.h1) : null,
          volume_6h_usd: attrs.volume_usd?.h6 ? parseFloat(attrs.volume_usd.h6) : null,
          
          // Variations
          price_change_percentage_1h: attrs.price_change_percentage?.h1 ? parseFloat(attrs.price_change_percentage.h1) : null,
          price_change_percentage_6h: attrs.price_change_percentage?.h6 ? parseFloat(attrs.price_change_percentage.h6) : null,
          price_change_percentage_24h: attrs.price_change_percentage?.h24 ? parseFloat(attrs.price_change_percentage.h24) : null,
          
          // Adresses
          base_token_address: token.token_address,
          
          // M√©tadonn√©es
          pool_created_at: attrs.created_at || null,
          gecko_token_image_url: attrs.image_url || null,
          gecko_total_supply: attrs.total_supply || null
        };
        
        cache.set(cacheKey, {
          data: enrichedData,
          timestamp: Date.now()
        });
        
        console.log(`‚úÖ [GECKO TOKEN FALLBACK ENRICHED] ${token.token_address} - Prix: $${attrs.price_usd} - Source: tokens_api_v2`);
        return { ...token, ...enrichedData };
      }
    }
    
  } catch (error) {
    console.log(`‚ö†Ô∏è [GECKO SKIP] ${token.token_address}: ${error.message}`);
  }
  
  console.log(`üîö [GECKO END] Enrichissement termin√© pour ${token.token_address} - Pas d'enrichissement`);
  return { ...token, gecko_enriched: false };
}

/**
 * Calculer les statistiques de p√©riode (7j, all time)
 */
function calculatePeriodStats(data: any, period: string): any {
  // Cette fonction peut √™tre √©tendue selon les besoins sp√©cifiques
  const stats = {
    period: period,
    calculated_at: new Date().toISOString()
  };

  if (data.data && data.data.tokens) {
    const tokens = data.data.tokens;
    
    // Calculer les stats de base
    const totalPnl = tokens.reduce((sum: number, token: any) => {
      return sum + (token.realized_pnl || 0) + (token.unrealized_pnl || 0);
    }, 0);

    const totalVolume = tokens.reduce((sum: number, token: any) => {
      return sum + (token.volume_usd || 0);
    }, 0);

    const winningTrades = tokens.filter((token: any) => 
      (token.realized_pnl || 0) + (token.unrealized_pnl || 0) > 0
    ).length;

    const totalTrades = tokens.length;

    return {
      ...stats,
      total_pnl: totalPnl,
      total_volume: totalVolume,
      total_trades: totalTrades,
      winning_trades: winningTrades,
      win_rate: totalTrades > 0 ? winningTrades / totalTrades : 0,
      tokens_count: totalTrades
    };
  }

  return stats;
}

/**
 * Donn√©es stables pour les tests et fallback
 */
function getStableWalletData(walletAddress: string): any {
  if (walletAddress === 'ABdAsGjQv1bLLvzgcqEWJmAuwNbUJyfNUausyTVe7STB') {
    return {
      wallet_address: walletAddress,
      total_usd_value: 127500.45,
      total_pnl_usd: 34250.80,
      win_rate: 73.5,
      total_trades: 156,
      alpha_score: 8.7,
      tokens: [
        {
          mint: "So11111111111111111111111111111111111111112",
          symbol: "SOL",
          name: "Solana",
          balance: 125.45,
          usd_value: 18500.75,
          total_pnl_usd: 4250.30,
          roi_percentage: 187.5,
          trade_count: 23,
          win_rate: 78.3
        }
      ],
      data_source: 'stable_fallback',
      timestamp: new Date().toISOString()
    };
  }
  
  // G√©n√©rer des donn√©es coh√©rentes bas√©es sur l'adresse
  const hash = walletAddress.split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
  
  const baseValue = Math.abs(hash) % 100000;
  
  return {
    wallet_address: walletAddress,
    total_usd_value: baseValue * 0.25,
    total_pnl_usd: baseValue * 0.15,
    win_rate: ((baseValue % 80) + 20) / 100 * 100, // 20-100%
    total_trades: Math.floor(baseValue / 100) + 10,
    alpha_score: (baseValue % 100) / 10, // 0-10
    tokens: [],
    data_source: 'stable_generated',
    timestamp: new Date().toISOString()
  };
}

// === FONCTION UTILITAIRE - MISE √Ä JOUR WALLET SUMMARY ===
async function updateWalletSummary(walletAddress: string, walletData: any, supabase: any) {
  try {
    console.log(`üìä [WALLET SUMMARY] Calcul des m√©triques pour ${walletAddress}`);
    
    // Extraire les m√©triques depuis les donn√©es Cielo
    const statsAggregated = walletData.stats_aggregated || {};
    const tokensPnl = walletData.tokens_pnl || {};
    const portfolio = walletData.portfolio || {};
    const stats = walletData.stats || {}; // Donn√©es stats d√©taill√©es
    const statsData = stats.data || {}; // Donn√©es des stats depuis /enhanced-stats
    
    // Calculer les m√©triques agr√©g√©es de base
    const totalPnl = tokensPnl.total_pnl_usd || statsAggregated.total_pnl || statsData.total_pnl || 0;
    const winRate = tokensPnl.winrate || statsAggregated.winrate || statsData.winrate || 0;
    const totalTokensTraded = tokensPnl.total_tokens_traded || statsAggregated.total_tokens_traded || 0;
    const totalValue = portfolio.data?.total_usd || 0;
    const tokenCount = portfolio.data?.portfolio?.length || 0;
    
    // Extraire les nouvelles m√©triques de trading demand√©es
    const averageHoldingTime = statsData.average_holding_time || statsAggregated.average_holding_time || 0;
    const totalRoiPercentage = statsData.total_roi_percentage || statsAggregated.total_roi_percentage || tokensPnl.total_roi_percentage || 0;
    const swapCount = statsData.swap_count || statsAggregated.swap_count || 0;
    const firstSwapTimestamp = statsData.first_swap_timestamp || statsAggregated.first_swap_timestamp || null;
    const lastSwapTimestamp = statsData.last_swap_timestamp || statsAggregated.last_swap_timestamp || null;
    const uniqueTradingDays = statsData.unique_trading_days || statsAggregated.unique_trading_days || 0;
    const consecutiveTradingDays = statsData.consecutive_trading_days || statsAggregated.consecutive_trading_days || 0;
    const averageTradesPerToken = statsData.average_trades_per_token || statsAggregated.average_trades_per_token || 0;
    
    // R√©cup√©rer le nombre de tokens depuis wallet_tokens_extended si portfolio est vide
    let actualTokenCount = tokenCount;
    if (tokenCount === 0) {
      try {
        const { data: tokensExtended, error: tokensError } = await supabase
          .from('wallet_tokens_extended')
          .select('id', { count: 'exact' })
          .eq('wallet_address', walletAddress);
        
        if (!tokensError && tokensExtended) {
          actualTokenCount = tokensExtended.length;
          console.log(`üìä [WALLET SUMMARY] Tokens trouv√©s dans wallet_tokens_extended: ${actualTokenCount}`);
        }
      } catch (error) {
        console.log(`‚ö†Ô∏è [WALLET SUMMARY] Erreur r√©cup√©ration tokens: ${error.message}`);
      }
    }
    
    // Calculer des m√©triques additionnelles depuis les tokens
    let avgMarketCap = 0;
    let avgReliabilityScore = 0;
    let tokensWithMarketCap = 0;
    let top5Concentration = 0;
    
    if (portfolio.data?.portfolio && Array.isArray(portfolio.data.portfolio)) {
      const tokens = portfolio.data.portfolio;
      const marketCaps = tokens
        .map(t => t.geckoterminal_complete_data?.market_cap_usd || 0)
        .filter(mc => mc > 0);
      
      const reliabilityScores = tokens
        .map(t => t.geckoterminal_complete_data?.reliability_score?.total_score || 0)
        .filter(rs => rs > 0);
      
      avgMarketCap = marketCaps.length > 0 ? 
        marketCaps.reduce((sum, mc) => sum + mc, 0) / marketCaps.length : 0;
      
      avgReliabilityScore = reliabilityScores.length > 0 ? 
        reliabilityScores.reduce((sum, rs) => sum + rs, 0) / reliabilityScores.length : 0;
      
      tokensWithMarketCap = marketCaps.length;
      
      // Calculer la concentration des top 5 tokens
      const tokenValues = tokens
        .map(t => t.total_usd_value || 0)
        .sort((a, b) => b - a);
      const top5Value = tokenValues.slice(0, 5).reduce((sum, val) => sum + val, 0);
      top5Concentration = totalValue > 0 ? (top5Value / totalValue) * 100 : 0;
    }
    
    // Calculer un score de performance global
    const performanceScore = Math.min(Math.max(
      (totalPnl / 1000) * 10 + // PnL factor
      (winRate / 10) + // Win rate factor  
      (totalTokensTraded / 5) - // Diversification factor
      Math.max(0, (top5Concentration - 50) / 10), // Concentration penalty
      0), 100);
    
    // Pr√©parer les donn√©es √† sauvegarder (incluant les nouvelles m√©triques)
    const walletSummary = {
      wallet_address: walletAddress,
      total_pnl: totalPnl,
      total_value_usd: totalValue,
      win_rate: winRate,
      token_count: actualTokenCount,
      total_trades: totalTokensTraded,
      performance_score: performanceScore,
      avg_token_market_cap: avgMarketCap,
      avg_reliability_score: avgReliabilityScore,
      tokens_with_market_cap: tokensWithMarketCap,
      top_5_tokens_concentration_pct: top5Concentration,
      last_updated: new Date().toISOString(),
      api_total_tokens_traded: totalTokensTraded,
      api_total_pnl_usd: totalPnl,
      api_winrate: winRate,
      analysis_score: performanceScore,
      enriched_tokens_count: tokensWithMarketCap,
      enriched_tokens_percentage: actualTokenCount > 0 ? (tokensWithMarketCap / actualTokenCount) * 100 : 0,
      
      // ‚ú® NOUVELLES M√âTRIQUES DE TRADING DEMAND√âES
      average_holding_time: averageHoldingTime,
      total_roi_percentage: totalRoiPercentage,
      swap_count: swapCount,
      first_swap_timestamp: firstSwapTimestamp,
      last_swap_timestamp: lastSwapTimestamp,
      unique_trading_days: uniqueTradingDays,
      consecutive_trading_days: consecutiveTradingDays,
      average_trades_per_token: averageTradesPerToken
    };
    
    console.log(`üíæ [WALLET SUMMARY] M√©triques calcul√©es:`, {
      totalPnl: totalPnl.toLocaleString(),
      winRate: winRate.toFixed(1) + '%',
      tokenCount: actualTokenCount,
      performanceScore: performanceScore.toFixed(1),
      averageHoldingTime: averageHoldingTime,
      swapCount: swapCount,
      uniqueTradingDays: uniqueTradingDays
    });
    
    // Sauvegarder dans wallets_extended avec upsert
    const { data, error } = await supabase
      .from('wallets_extended')
      .upsert(walletSummary, {
        onConflict: 'wallet_address'
      })
      .select();
    
    if (error) {
      console.error(`‚ùå [WALLET SUMMARY] Erreur sauvegarde: ${error.message}`);
      return { success: false, error: error.message };
    }
    
    console.log(`‚úÖ [WALLET SUMMARY] M√©triques sauvegard√©es pour ${walletAddress}`);
    return { success: true, data: walletSummary };
    
  } catch (error) {
    console.error(`‚ùå [WALLET SUMMARY] Erreur: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Fonction pour persister les tokens enrichis en base de donn√©es
 */
async function persistEnrichedTokens(walletAddress: string, enrichedTokens: any[]): Promise<{ success: boolean; tokens_saved: number; enriched_tokens_saved?: number; error?: string }> {
  console.log(`üíæ [DB PERSIST] D√©but persistance de ${enrichedTokens.length} tokens enrichis pour ${walletAddress}`);
  
  if (!enrichedTokens || enrichedTokens.length === 0) {
    console.log(`‚ö†Ô∏è [DB PERSIST] Aucun token √† persister`);
    return { success: true, tokens_saved: 0 };
  }

  try {
    // Cr√©er le client Supabase
    const supabaseUrl = 'https://xkndddxqqlxqknbqtefv.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhrbmRkZHhxcWx4cWtuYnF0ZWZ2Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MzAxNjcxMSwiZXhwIjoyMDY4NTkyNzExfQ.k6ckJjZEpaNF2nwttZTg1iJ9i2SfzAXU75SLFYp3yDQ';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Pr√©parer les donn√©es pour insertion/mise √† jour
    const tokensToSave = enrichedTokens.map(token => ({
      wallet_address: walletAddress,
      token_address: token.token_address,
      symbol: token.token_symbol || token.symbol,
      name: token.token_name || token.name,
      chain: token.chain || 'solana',
      
      // Donn√©es de trading PnL
      total_pnl_usd: token.total_pnl_usd || 0,
      unrealized_pnl_usd: token.unrealized_pnl_usd || 0,
      roi_percentage: token.roi_percentage || 0,
      unrealized_roi_percentage: token.unrealized_roi_percentage || 0,
      num_swaps: token.num_swaps || 0,
      total_buy_usd: token.total_buy_usd || 0,
      total_sell_usd: token.total_sell_usd || 0,
      total_buy_amount: token.total_buy_amount || 0,
      total_sell_amount: token.total_sell_amount || 0,
      average_buy_price: token.average_buy_price || 0,
      average_sell_price: token.average_sell_price || 0,
      first_trade: token.first_trade || null,
      last_trade: token.last_trade || null,
      hold_time: token.hold_time || 0,
      holding_amount: token.holding_amount || 0,
      holding_amount_usd: token.holding_amount_usd || 0,
      token_price_usd: token.token_price_usd || 0,
      chart_link: token.chart_link || null,
      is_honeypot: token.is_honeypot || false,
      
      // Donn√©es d'enrichissement Gecko
      gecko_enriched: token.gecko_enriched || false,
      gecko_price_usd: token.gecko_price_usd || null,
      gecko_market_cap_usd: token.gecko_market_cap_usd || null,
      gecko_fdv_usd: token.fdv_usd || token.gecko_fdv_usd || null,
      gecko_liquidity_usd: token.liquidity_usd || token.gecko_liquidity_usd || null,
      gecko_volume_24h_usd: token.volume_24h_usd || token.gecko_volume_24h_usd || null,
      gecko_price_change_24h: token.price_change_24h || token.gecko_price_change_24h || null,
      gecko_gt_score: token.gt_score || token.gecko_gt_score || null,
      gecko_data_source: token.gecko_data_source || null,
      gecko_updated_at: token.gecko_updated_at || (token.gecko_enriched ? new Date().toISOString() : null),
      gecko_pool_address: token.gecko_pool_address || null,
      gecko_pool_id: token.gecko_pool_id || null,
      gecko_enrichment_method: token.gecko_enrichment_method || null,
      
      // M√©tadonn√©es
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }));

    console.log(`üíæ [DB PERSIST] Pr√©paration de ${tokensToSave.length} tokens pour upsert`);

    // Utiliser upsert pour ins√©rer/mettre √† jour
    const { data, error } = await supabase
      .from('wallet_tokens_extended')
      .upsert(tokensToSave, {
        onConflict: 'wallet_address,token_address',
        ignoreDuplicates: false
      })
      .select('wallet_address, token_address, gecko_enriched');

    if (error) {
      console.error(`‚ùå [DB PERSIST] Erreur Supabase:`, error);
      return { 
        success: false, 
        tokens_saved: 0, 
        error: error.message 
      };
    }

    const savedCount = data?.length || tokensToSave.length;
    const enrichedCount = tokensToSave.filter(t => t.gecko_enriched).length;
    
    console.log(`‚úÖ [DB PERSIST] ${savedCount} tokens sauvegard√©s (${enrichedCount} enrichis avec Gecko)`);
    
    return { 
      success: true, 
      tokens_saved: savedCount,
      enriched_tokens_saved: enrichedCount
    };

  } catch (error) {
    console.error(`‚ùå [DB PERSIST] Erreur inattendue:`, error);
    return { 
      success: false, 
      tokens_saved: 0, 
      error: error instanceof Error ? error.message : 'Erreur inconnue' 
    };
  }
}

serve(async (req) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'
  };

  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  // Initialiser le client Supabase
  const supabase = createClient(
    'https://xkndddxqqlxqknbqtefv.supabase.co',
    SUPABASE_ANON_KEY
  );

  try {
    const url = new URL(req.url);
    const pathParts = url.pathname.split('/').filter(Boolean);
    
    console.log(`üîç [ROUTE DEBUG] pathname=${url.pathname}, pathParts=${JSON.stringify(pathParts)}`);
    
    // Format attendu: /cielo-api/action/wallet_address
    // pathParts = ["cielo-api", "health"] ou ["cielo-api", "portfolio", "ABd..."]
    
    if (pathParts.length < 2 || pathParts[0] !== 'cielo-api') {
      return new Response(JSON.stringify({
        error: 'Invalid path format',
        expected: '/cielo-api/action/wallet_address',
        received: url.pathname,
        pathParts: pathParts
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
    
    const action = pathParts[1]; // health, portfolio, stats, etc.
    const walletAddress = pathParts[2]; // adresse du wallet (optionnel pour health)

    console.log(`üéØ [CIELO API] action="${action}", wallet="${walletAddress || 'none'}"`);

    // Le health check et test-gecko ne n√©cessitent pas d'adresse de wallet
    if (action === 'health') {
      return new Response(JSON.stringify({
        status: 'healthy',
        version: 'deno-cielo-api-v3',
        timestamp: new Date().toISOString(),
        cielo_base_url: CIELO_CONFIG.baseUrl,
        test_wallet: 'ABdAsGjQv1bLLvzgcqEWJmAuwNbUJyfNUausyTVe7STB',
        data_source: 'REAL_CIELO_API_WITH_FALLBACK',
        available_endpoints: ['portfolio', 'stats', 'stats-7d', 'profitability', 'profitability-7d', 'track-status', 'tokens-pnl', 'pnl', 'pnl-complete', 'complete', 'health', 'test-gecko', 'gecko-api-test', 'debug-tokens', 'debug-enrich-one', 'demo-p1-enrichment'],
        behavioral_analysis: 'Integrated ChatGPT copy trading analysis in /complete endpoint',
        copy_trading_criteria: 'Win rate 85%+, Anti-bot detection, Position sizing, Token strategy, Practical copy trading'
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Endpoint pour tester l'enrichissement Gecko directement
    if (action === 'test-gecko') {
      const testToken = {
        token_address: walletAddress || '25PwuUsuJ4PHtZ4TCprvmrVkbNQNvYuWj1CZd2xqbonk',
        token_symbol: 'SDOG',
        token_name: 'SDOG Test'
      };
      
      console.log(`üß™ [TEST GECKO] Test avec token: ${testToken.token_symbol} (${testToken.token_address})`);
      const enriched = await enrichTokenWithGecko(testToken);
      
      return new Response(JSON.stringify({
        success: true,
        test_type: walletAddress ? 'custom_token' : 'fixed_token',
        token_used: testToken.token_address,
        original: testToken,
        enriched: enriched,
        has_price: !!enriched.gecko_price_usd,
        price_found: enriched.gecko_price_usd,
        timestamp: new Date().toISOString()
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Endpoint complet pour tester l'API GeckoTerminal directement
    if (action === 'gecko-api-test') {
      const testType = pathParts[2]; // pools, token, networks, trending, etc.
      const tokenAddress = pathParts[3]; // adresse du token (optionnel)
      const network = pathParts[4] || 'solana'; // r√©seau (d√©faut: solana)
      
      console.log(`ü¶é [GECKO API TEST] Type: ${testType}, Token: ${tokenAddress || 'none'}, Network: ${network}`);        if (!testType) {
        return new Response(JSON.stringify({
          error: 'Type de test requis',
          usage: '/cielo-api/gecko-api-test/{type}/{tokenAddress?}/{network?}',
          available_types: ['pools', 'token', 'networks', 'trending', 'dexes', 'pool-specific', 'pool-p1'],
          examples: [
            '/cielo-api/gecko-api-test/pools/25PwuUsuJ4PHtZ4TCprvmrVkbNQNvYuWj1CZd2xqbonk/solana',
            '/cielo-api/gecko-api-test/token/25PwuUsuJ4PHtZ4TCprvmrVkbNQNvYuWj1CZd2xqbonk/solana',
            '/cielo-api/gecko-api-test/networks',
            '/cielo-api/gecko-api-test/trending/solana',
            '/cielo-api/gecko-api-test/pool-p1/8MsMB9zGkescT7r3mSA6uJdFthtgx3JHAn93b8swQicT/solana'
          ]
        }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
      
      try {
        let endpoint = '';
        let description = '';
        
        switch (testType) {
          case 'pools':
            if (!tokenAddress) {
              return new Response(JSON.stringify({
                error: 'Token address requis pour le test pools',
                usage: '/cielo-api/gecko-api-test/pools/{tokenAddress}/{network?}'
              }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            endpoint = `/networks/${network}/tokens/${tokenAddress}/pools?include=dex,base_token&page=1&limit=5`;
            description = `R√©cup√©ration des pools pour le token ${tokenAddress} sur ${network}`;
            break;
            
          case 'token':
            if (!tokenAddress) {
              return new Response(JSON.stringify({
                error: 'Token address requis pour le test token',
                usage: '/cielo-api/gecko-api-test/token/{tokenAddress}/{network?}'
              }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            endpoint = `/networks/${network}/tokens/${tokenAddress}`;
            description = `R√©cup√©ration des donn√©es du token ${tokenAddress} sur ${network}`;
            break;
            
          case 'networks':
            endpoint = '/networks';
            description = 'Liste des r√©seaux support√©s par GeckoTerminal';
            break;
            
          case 'trending':
            const trendingNetwork = tokenAddress || network;
            endpoint = `/networks/${trendingNetwork}/trending_pools`;
            description = `Pools tendance sur ${trendingNetwork}`;
            break;
            
          case 'dexes':
            const dexNetwork = tokenAddress || network;
            endpoint = `/networks/${dexNetwork}/dexes`;
            description = `Liste des DEX sur ${dexNetwork}`;
            break;
            
          case 'pool-specific':
            if (!tokenAddress) {
              return new Response(JSON.stringify({
                error: 'Pool address requis pour le test pool-specific',
                usage: '/cielo-api/gecko-api-test/pool-specific/{poolAddress}/{network?}'
              }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            endpoint = `/networks/${network}/pools/${tokenAddress}`;
            description = `Donn√©es sp√©cifiques du pool ${tokenAddress} sur ${network}`;
            break;
            
          case 'pool-p1':
            if (!tokenAddress) {
              return new Response(JSON.stringify({
                error: 'Pool address requis pour le test pool-p1',
                usage: '/cielo-api/gecko-api-test/pool-p1/{poolAddress}/{network?}',
                example: '/cielo-api/gecko-api-test/pool-p1/8MsMB9zGkescT7r3mSA6uJdFthtgx3JHAn93b8swQicT/solana'
              }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            // Utiliser l'API P1 avec tous les param√®tres d'inclusion
            endpoint = `/${network}/pools/${tokenAddress}?include=dex%2Cdex.network.explorers%2Cdex_link_services%2Cnetwork_link_services%2Cpairs%2Ctoken_link_services%2Ctokens.token_security_metric%2Ctokens.tags%2Cpool_locked_liquidities&base_token=0`;
            description = `Test API P1 avanc√© pour pool ${tokenAddress} sur ${network} avec enrichissement complet`;
            
            // Pour pool-p1, utiliser la fonction sp√©cialis√©e P1
            console.log(`üåê [GECKO P1 TEST] ${description}`);
            console.log(`üîó [GECKO P1 TEST] Endpoint: ${endpoint}`);
            
            const startTimeP1 = Date.now();
            const geckoP1Data = await geckoterminalP1Request(endpoint);
            const durationP1 = Date.now() - startTimeP1;
            
            // Analyser la structure sp√©cifique P1
            const p1ResponseAnalysis: any = {
              duration_ms: durationP1,
              api_source: 'geckoterminal_p1',
              has_data: !!geckoP1Data.data,
              data_type: typeof geckoP1Data.data,
              pool_id: geckoP1Data.data?.id,
              pool_type: geckoP1Data.data?.type,
              has_attributes: !!geckoP1Data.data?.attributes,
              top_level_keys: Object.keys(geckoP1Data),
              has_included: !!geckoP1Data.included,
              included_count: geckoP1Data.included ? geckoP1Data.included.length : 0,
              included_types: geckoP1Data.included ? [...new Set(geckoP1Data.included.map((item: any) => item.type))] : []
            };
            
            // Analyser les attributs du pool P1
            if (geckoP1Data.data?.attributes) {
              const attrs = geckoP1Data.data.attributes;
              p1ResponseAnalysis.pool_attributes = {
                has_price: !!attrs.price_in_usd,
                has_fdv: !!attrs.fully_diluted_valuation,
                has_liquidity: !!attrs.reserve_in_usd,
                has_volume: !!(attrs.from_volume_in_usd || attrs.to_volume_in_usd),
                has_price_changes: !!attrs.price_percent_changes,
                has_gt_score: !!attrs.gt_score,
                main_metrics: {
                  price_usd: attrs.price_in_usd,
                  fdv_usd: attrs.fully_diluted_valuation,
                  liquidity_usd: attrs.reserve_in_usd,
                  gt_score: attrs.gt_score
                }
              };
            }
            
            // Analyser les tokens inclus
            if (geckoP1Data.included) {
              const tokens = geckoP1Data.included.filter((item: any) => item.type === 'token');
              p1ResponseAnalysis.tokens_included = {
                count: tokens.length,
                tokens: tokens.map((token: any) => ({
                  id: token.id,
                  address: token.attributes?.address,
                  name: token.attributes?.name,
                  symbol: token.attributes?.symbol,
                  has_market_cap: !!token.attributes?.market_cap_in_usd
                }))
              };
            }
            
            return new Response(JSON.stringify({
              success: true,
              test_type: 'pool-p1',
              description,
              endpoint,
              analysis: p1ResponseAnalysis,
              raw_data: geckoP1Data,
              url_used: `${GECKOTERMINAL_CONFIG.baseUrlP1}${endpoint}`
            }), {
              status: 200,
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
            
          default:
            return new Response(JSON.stringify({
              error: `Type de test "${testType}" non support√©`,
              available_types: ['pools', 'token', 'networks', 'trending', 'dexes', 'pool-specific', 'pool-p1']
            }), {
              status: 400,
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        console.log(`üåê [GECKO API TEST] ${description}`);
        console.log(`üîó [GECKO API TEST] Endpoint: ${endpoint}`);
        
        const startTime = Date.now();
        const geckoData = await geckoterminalRequest(endpoint);
        const duration = Date.now() - startTime;
        
        // Analyser la structure de la r√©ponse
        const responseAnalysis: any = {
          duration_ms: duration,
          has_data: !!geckoData.data,
          data_type: Array.isArray(geckoData.data) ? 'array' : typeof geckoData.data,
          data_count: Array.isArray(geckoData.data) ? geckoData.data.length : (geckoData.data ? 1 : 0),
          top_level_keys: Object.keys(geckoData),
          has_included: !!geckoData.included,
          included_count: geckoData.included ? geckoData.included.length : 0
        };
        
        // Preview des premi√®res donn√©es
        let dataPreview: any = null;
        if (geckoData.data) {
          if (Array.isArray(geckoData.data)) {
            dataPreview = {
              total_items: geckoData.data.length,
              first_item_keys: geckoData.data[0] ? Object.keys(geckoData.data[0]) : null,
              first_item_id: geckoData.data[0]?.id,
              first_item_type: geckoData.data[0]?.type,
              first_item_attributes_keys: geckoData.data[0]?.attributes ? Object.keys(geckoData.data[0].attributes) : null
            };
          } else {
            dataPreview = {
              item_keys: Object.keys(geckoData.data),
              item_id: geckoData.data.id,
              item_type: geckoData.data.type,
              attributes_keys: geckoData.data.attributes ? Object.keys(geckoData.data.attributes) : null
            };
          }
        }
        
        // Preview des donn√©es included
        let includedPreview: any = null;
        if (geckoData.included && Array.isArray(geckoData.included)) {
          const groupedByType = geckoData.included.reduce((acc: any, item: any) => {
            const type = item.type || 'unknown';
            if (!acc[type]) acc[type] = 0;
            acc[type]++;
            return acc;
          }, {});
          
          includedPreview = {
            total_included: geckoData.included.length,
            types_breakdown: groupedByType,
            first_included_keys: geckoData.included[0] ? Object.keys(geckoData.included[0]) : null
          };
        }
        
        return new Response(JSON.stringify({
          success: true,
          test_type: testType,
          description: description,
          endpoint_tested: endpoint,
          full_url: `${GECKOTERMINAL_CONFIG.baseUrl}${endpoint}`,
          network: network,
          token_address: tokenAddress,
          response_analysis: responseAnalysis,
          data_preview: dataPreview,
          included_preview: includedPreview,
          raw_response: geckoData, // R√©ponse compl√®te pour debug
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
      } catch (error) {
        console.error(`‚ùå [GECKO API TEST] Erreur: ${error.message}`);
        return new Response(JSON.stringify({
          success: false,
          test_type: testType,
          error: error.message,
          endpoint_attempted: 'error_before_endpoint_set',
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Endpoint pour examiner la structure des tokens TRPC SANS enrichissement
    if (action === 'debug-tokens') {
      console.log(`üîç [DEBUG TOKENS] Examen structure tokens pour ${walletAddress}`);
      
      const trpcInput = {
        "0": {
          "json": {
            "wallet": walletAddress,
            "chains": "",
            "timeframe": "",
            "sortBy": "",
            "page": "1",
            "tokenFilter": ""
          }
        }
      };
      
      const encodedInput = encodeURIComponent(JSON.stringify(trpcInput));
      const trpcUrl = `https://app.cielo.finance/api/trpc/profile.fetchTokenPnlSlow?batch=1&input=${encodedInput}`;
      
      try {
        const trpcResponse = await fetch(trpcUrl, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Referer': 'https://app.cielo.finance/',
            'Origin': 'https://app.cielo.finance'
          }
        });
        
        if (!trpcResponse.ok) {
          throw new Error(`TRPC request failed: ${trpcResponse.status} ${trpcResponse.statusText}`);
        }
        
        const trpcData = await trpcResponse.json();
        console.log(`üîç [DEBUG TOKENS] R√©ponse TRPC brute:`, JSON.stringify(trpcData, null, 2));
        console.log(`üîç [DEBUG TOKENS] Structure trpcData:`, Object.keys(trpcData));
        console.log(`üîç [DEBUG TOKENS] trpcData[0]:`, trpcData[0] ? Object.keys(trpcData[0]) : 'null');
        console.log(`üîç [DEBUG TOKENS] trpcData[0]?.result:`, trpcData[0]?.result ? Object.keys(trpcData[0].result) : 'null');
        console.log(`üîç [DEBUG TOKENS] trpcData[0]?.result?.data:`, trpcData[0]?.result?.data ? Object.keys(trpcData[0].result.data) : 'null');
        
        const tokenData = trpcData[0]?.result?.data;
        
        if (!tokenData) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Format de r√©ponse TRPC invalide',
            debug_type: 'tokens_structure_analysis',
            raw_trpc_response: trpcData,
            trpc_structure: {
              is_array: Array.isArray(trpcData),
              length: trpcData?.length,
              first_element_keys: trpcData[0] ? Object.keys(trpcData[0]) : null,
              has_result: !!trpcData[0]?.result,
              has_data: !!trpcData[0]?.result?.data
            },
            timestamp: new Date().toISOString()
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        // CORRECTION CRITIQUE : Les donn√©es sont dans data.json.data.tokens !
        const realTokenData = tokenData.json?.data;
        const tokens = realTokenData?.tokens || [];
        console.log(`üîç [DEBUG TOKENS] ${tokens.length} tokens trouv√©s`);
        
        // Analyser les 3 premiers tokens en d√©tail
        const tokenAnalysis = tokens.slice(0, 3).map((token, index) => {
          return {
            index: index,
            keys: Object.keys(token),
            token_address: token.token_address,
            token_symbol: token.token_symbol,
            token_name: token.token_name,
            has_address: !!token.token_address,
            address_type: typeof token.token_address,
            address_length: token.token_address?.length || 0,
            sample_data: {
              pnl: token.pnl,
              realized_pnl: token.realized_pnl,
              unrealized_pnl: token.unrealized_pnl
            }
          };
        });
        
        return new Response(JSON.stringify({
          success: true,
          debug_type: 'tokens_structure_analysis',
          wallet_address: walletAddress,
          total_tokens: tokens.length,
          token_analysis: tokenAnalysis,
          first_token_full: tokens[0] || null,
          data_structure: {
            top_level_keys: Object.keys(tokenData),
            has_json_key: !!tokenData.json,
            json_keys: tokenData.json ? Object.keys(tokenData.json) : null,
            has_tokens_array: Array.isArray(realTokenData?.tokens),
            tokens_count: tokens.length
          },
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          debug_type: 'tokens_structure_analysis',
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Endpoint pour tester l'enrichissement d'UN SEUL token avec debug d√©taill√©
    if (action === 'debug-enrich-one') {
      console.log(`üß™ [DEBUG ENRICH ONE] Test enrichissement d'un token pour ${walletAddress}`);
      
      // D'abord r√©cup√©rer les tokens TRPC
      const trpcInput = {
        "0": {
          "json": {
            "wallet": walletAddress,
            "chains": "",
            "timeframe": "",
            "sortBy": "",
            "page": "1",
            "tokenFilter": ""
          }
        }
      };
      
      const encodedInput = encodeURIComponent(JSON.stringify(trpcInput));
      const trpcUrl = `https://app.cielo.finance/api/trpc/profile.fetchTokenPnlSlow?batch=1&input=${encodedInput}`;
      
      try {
        console.log(`üîó [DEBUG ENRICH ONE] Appel TRPC: ${trpcUrl}`);
        const trpcResponse = await fetch(trpcUrl, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Referer': 'https://app.cielo.finance/',
            'Origin': 'https://app.cielo.finance'
          }
        });
        
        if (!trpcResponse.ok) {
          throw new Error(`TRPC request failed: ${trpcResponse.status} ${trpcResponse.statusText}`);
        }
        
        const trpcData = await trpcResponse.json();
        const tokenData = trpcData[0]?.result?.data;
        const realTokenData = tokenData?.json?.data; // CORRECTION CRITIQUE
        const tokens = realTokenData?.tokens || [];
        
        if (tokens.length === 0) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Aucun token trouv√© dans la r√©ponse TRPC',
            debug_type: 'single_token_enrichment',
            timestamp: new Date().toISOString()
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        // Prendre le premier token pour test
        const originalToken = tokens[0];
        console.log(`üéØ [DEBUG ENRICH ONE] Token s√©lectionn√©: ${originalToken.token_symbol} (${originalToken.token_address})`);
        console.log(`üìã [DEBUG ENRICH ONE] Token original keys:`, Object.keys(originalToken));
        console.log(`üîç [DEBUG ENRICH ONE] Token original data:`, JSON.stringify({
          token_address: originalToken.token_address,
          token_symbol: originalToken.token_symbol,
          token_name: originalToken.token_name,
          has_address: !!originalToken.token_address,
          address_valid: originalToken.token_address && originalToken.token_address.length > 20
        }));
        
        // Pr√©parer le token pour enrichissement (comme dans le vrai code)
        const tokenToEnrich = {
          token_address: originalToken.token_address,
          token_symbol: originalToken.token_symbol,
          token_name: originalToken.token_name,
          ...originalToken
        };
        
        console.log(`üîÑ [DEBUG ENRICH ONE] D√©but enrichissement...`);
        const startTime = Date.now();
        
        // Enrichir le token
        const enrichedToken = await enrichTokenWithGecko(tokenToEnrich);
        
        const enrichmentDuration = Date.now() - startTime;
        console.log(`‚è±Ô∏è [DEBUG ENRICH ONE] Enrichissement termin√© en ${enrichmentDuration}ms`);
        
        // Analyser le r√©sultat
        const wasEnriched = !!enrichedToken.gecko_price_usd;
        const enrichedKeys = Object.keys(enrichedToken);
        const newKeys = enrichedKeys.filter(key => !Object.keys(originalToken).includes(key));
        
        console.log(`üìä [DEBUG ENRICH ONE] R√©sultat: enrichi=${wasEnriched}, nouvelles cl√©s=${newKeys.length}`);
        
        return new Response(JSON.stringify({
          success: true,
          debug_type: 'single_token_enrichment',
          wallet_address: walletAddress,
          enrichment_result: {
            was_enriched: wasEnriched,
            duration_ms: enrichmentDuration,
            original_keys_count: Object.keys(originalToken).length,
            enriched_keys_count: enrichedKeys.length,
            new_keys: newKeys,
            gecko_price_found: enrichedToken.gecko_price_usd,
            gecko_market_cap_found: enrichedToken.gecko_market_cap_usd
          },
          original_token: {
            token_address: originalToken.token_address,
            token_symbol: originalToken.token_symbol,
            token_name: originalToken.token_name,
            sample_keys: Object.keys(originalToken).slice(0, 10)
          },
          enriched_token: {
            token_address: enrichedToken.token_address,
            token_symbol: enrichedToken.token_symbol,
            gecko_price_usd: enrichedToken.gecko_price_usd,
            gecko_market_cap_usd: enrichedToken.gecko_market_cap_usd,
            gecko_updated_at: enrichedToken.gecko_updated_at
          },
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
      } catch (error) {
        console.error(`‚ùå [DEBUG ENRICH ONE] Erreur: ${error.message}`);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          debug_type: 'single_token_enrichment',
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Endpoint pour d√©montrer l'enrichissement P1 avec tokens de test
    if (action === 'demo-p1-enrichment') {
      console.log(`üéØ [DEMO P1] D√©monstration enrichissement P1 pour ${walletAddress || 'tokens de test'}`);
      
      // Tokens de test populaires avec leurs pools connus
      const testTokens = [
        {
          token_address: '25PwuUsuJ4PHtZ4TCprvmrVkbNQNvYuWj1CZd2xqbonk',
          token_symbol: 'SDOG',
          token_name: 'Smiling Dog',
          pool_address: '8MsMB9zGkescT7r3mSA6uJdFthtgx3JHAn93b8swQicT'
        },
        {
          token_address: 'So11111111111111111111111111111111111111112',
          token_symbol: 'SOL',
          token_name: 'Wrapped SOL',
          pool_address: '58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2'
        },
        {
          token_address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
                   token_symbol: 'USDC',
          token_name: 'USD Coin',
          pool_address: '58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2'
        }
      ];
      
      const enrichmentResults: any[] = [];
      let successCount = 0;
      let totalTime = 0;
      
      console.log(`üîÑ [DEMO P1] Enrichissement de ${testTokens.length} tokens avec API P1...`);
      
      for (const token of testTokens) {
        try {
          const startTime = Date.now();
          
          // Utiliser l'enrichissement P1 direct
          const enriched = await enrichTokenWithGeckoP1Pool(token, token.pool_address, 'solana');
          
          const duration = Date.now() - startTime;
          totalTime += duration;
          
          const wasEnriched = !!enriched.fdv_usd;
          if (wasEnriched) successCount++;
          
          enrichmentResults.push({
            original: {
              address: token.token_address,
              symbol: token.token_symbol,
              name: token.token_name
            },
            enriched: {
              gecko_enriched: wasEnriched,
              gecko_data_source: enriched.gecko_data_source,
              price_usd: enriched.price_usd,
              fdv_usd: enriched.fdv_usd,
              market_cap_usd: enriched.market_cap_usd,
              liquidity_usd: enriched.liquidity_usd,
              gt_score: enriched.gt_score,
              gt_score_details: enriched.gt_score_details,
              pool_fee: enriched.pool_fee,
              swap_count_24h: enriched.swap_count_24h,
              is_nsfw: enriched.is_nsfw
            },
            metrics: {
              enrichment_duration_ms: duration,
              pool_used: token.pool_address,
              success: wasEnriched
            }
          });
          
          console.log(`‚úÖ [DEMO P1] ${token.token_symbol}: ${wasEnriched ? 'ENRICHI' : 'SKIP'} (${duration}ms)`);
          
        } catch (error) {
          console.log(`‚ùå [DEMO P1] ${token.token_symbol}: ERROR - ${error.message}`);
          enrichmentResults.push({
            original: {
              address: token.token_address,
              symbol: token.token_symbol,
              name: token.token_name
            },
            enriched: null,
            metrics: {
              error: error.message,
              success: false
            }
          });
        }
      }
      
      return new Response(JSON.stringify({
        success: true,
        demo_type: 'p1_enrichment_showcase',
        summary: {
          total_tokens: testTokens.length,
          successfully_enriched: successCount,
          success_rate: `${Math.round((successCount / testTokens.length) * 100)}%`,
          total_duration_ms: totalTime,
          average_duration_ms: Math.round(totalTime / testTokens.length)
        },
        api_capabilities: {
          price_usd: 'Prix en USD haute pr√©cision',
          fdv_usd: 'Fully Diluted Valuation (indisponible en V2)',
          market_cap_usd: 'Market Cap par token',
          gt_score: 'Score de qualit√© GeckoTerminal (0-100)',
          gt_score_details: 'D√©tail du score par cat√©gorie',
          liquidity_usd: 'Liquidit√© totale du pool',
          pool_fee: 'Frais du pool',
          swap_count_24h: 'Nombre de swaps 24h',
          security_metrics: 'M√©triques de s√©curit√© avanc√©es',
          tags_and_metadata: 'Tags et m√©tadonn√©es enrichies'
        },
        enrichment_results: enrichmentResults,
        p1_api_url: 'https://app.geckoterminal.com/api/p1/{network}/pools/{poolAddress}?include=dex%2Cdex.network.explorers%2Cdex_link_services%2Cnetwork_link_services%2Cpairs%2Ctoken_link_services%2Ctokens.token_security_metric%2Ctokens.tags%2Cpool_locked_liquidities&base_token=0',
        timestamp: new Date().toISOString()
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    if (!walletAddress) {
      return new Response(JSON.stringify({ 
        error: 'Wallet address required',
        example: '/cielo-api/portfolio/ABdAsGjQv1bLLvzgcqEWJmAuwNbUJyfNUausyTVe7STB',
        received_action: action,
        available_actions: ['portfolio', 'stats', 'stats-7d', 'pnl', 'pnl-complete', 'complete', 'health', 'test-gecko', 'debug-tokens', 'debug-enrich-one']
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    try {
      switch (action) {
        case 'portfolio': {
          console.log(`üìã [PORTFOLIO] R√©cup√©ration du portfolio pour ${walletAddress}`);
          const data = await cieloRequest(`/wallet/${walletAddress}/portfolio`);
          
          // Enrichir avec Geckoterminal si possible
          if (data.data && data.data.portfolio && Array.isArray(data.data.portfolio)) {
            console.log(`üîÑ [PORTFOLIO] Enrichissement de ${data.data.portfolio.length} tokens`);
            for (let i = 0; i < data.data.portfolio.length && i < 5; i++) { // Limiter √† 5 pour √©viter timeout
              data.data.portfolio[i] = await enrichTokenWithGecko(data.data.portfolio[i]);
            }
          }
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            enriched_with_gecko: true,
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'stats': {
          console.log(`üìä [STATS ALL TIME] R√©cup√©ration des stats pour ${walletAddress}`);
          const data = await cieloRequest(`/enhanced-stats/aggregated/${walletAddress}?days=max`);
          const periodStats = calculatePeriodStats(data, 'all_time');
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            period_stats: periodStats,
            source: 'CIELO_API',
            endpoint_used: '/enhanced-stats/aggregated',
            cielo_url: `${CIELO_CONFIG.baseUrl}/enhanced-stats/aggregated/${walletAddress}?days=max`,
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'stats-7d': {
          console.log(`üìä [STATS 7D] R√©cup√©ration des stats 7j pour ${walletAddress}`);
          const data = await cieloRequest(`/enhanced-stats/aggregated/${walletAddress}?days=7`);
          const periodStats = calculatePeriodStats(data, '7_days');
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            period_stats: periodStats,
            source: 'CIELO_API',
            endpoint_used: '/enhanced-stats/aggregated',
            period: '7_days',
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'profitability': {
          console.log(`üíπ [PROFITABILITY] R√©cup√©ration des donn√©es de profitabilit√© pour ${walletAddress}`);
          const data = await cieloRequest(`/enhanced-stats/profitability/${walletAddress}?days=max`);
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            endpoint_used: '/enhanced-stats/profitability',
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'profitability-7d': {
          console.log(`üíπ [PROFITABILITY 7D] R√©cup√©ration de la profitabilit√© 7j pour ${walletAddress}`);
          const data = await cieloRequest(`/enhanced-stats/profitability/${walletAddress}?days=7`);
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            endpoint_used: '/enhanced-stats/profitability',
            period: '7_days',
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'pnl': {
          console.log(`üí∞ [PNL] R√©cup√©ration du PnL pour ${walletAddress}`);
          const data = await cieloRequest(`/wallet/${walletAddress}/pnl`);
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'pnl-complete': {
          console.log(`üí∞ [PNL COMPLETE] R√©cup√©ration du PnL complet pour ${walletAddress}`);
          const data = await cieloRequest(`/wallet/${walletAddress}/pnl?include_tokens=true`);
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            include_tokens: true,
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'complete': {
          console.log(`üîÑ [COMPLETE] R√©cup√©ration des donn√©es compl√®tes pour ${walletAddress}`);
          
          // Fonction helper pour appeler tokens-pnl avec TRPC
          const fetchTokensPnlTRPC = async () => {
            const trpcInput = {
              "0": {
                "json": {
                  "wallet": walletAddress,
                  "chains": "",
                  "timeframe": "",
                  "sortBy": "",
                  "page": "1",
                  "tokenFilter": ""
                }
              }
            };
            
            const encodedInput = encodeURIComponent(JSON.stringify(trpcInput));
            const trpcUrl = `https://app.cielo.finance/api/trpc/profile.fetchTokenPnlSlow?batch=1&input=${encodedInput}`;
            
            const trpcResponse = await fetch(trpcUrl, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Referer': 'https://app.cielo.finance/',
                'Origin': 'https://app.cielo.finance'
              }
            });
            
            if (!trpcResponse.ok) {
              throw new Error(`TRPC request failed: ${trpcResponse.status} ${trpcResponse.statusText}`);
            }
            
            const trpcData = await trpcResponse.json();
            if (!trpcData[0] || !trpcData[0].result || !trpcData[0].result.data) {
              throw new Error('Format de r√©ponse TRPC invalide');
            }
            
            return trpcData[0].result.data.json?.data; // CORRECTION CRITIQUE
          };
          
          // Appeler tous les endpoints d√©couverts dans les requ√™tes TRPC + tokens-pnl TRPC
          const [portfolioData, statsAggregatedData, profitabilityData, trackStatusData, tokensPnlData] = await Promise.allSettled([
            cieloRequest(`/wallet/${walletAddress}/portfolio`),
            cieloRequest(`/enhanced-stats/aggregated/${walletAddress}?days=max`),
            cieloRequest(`/enhanced-stats/profitability/${walletAddress}?days=max`),
            cieloRequest(`/wallet/${walletAddress}/track-status`),
            fetchTokensPnlTRPC()
          ]);

          const result: any = {
            success: true,
            wallet_address: walletAddress,
            timestamp: new Date().toISOString(),
            source: 'CIELO_API',
            trpc_equivalent: 'profile.getWalletPortfolio + profile.getEnhancedStatsAggregated + profile.getEnhancedStatsProfitability + profile.getWalletGlobalTrackStatus + profile.fetchTokenPnlSlow',
            endpoints_called: [
              `/wallet/${walletAddress}/portfolio`,
              `/enhanced-stats/aggregated/${walletAddress}?days=max`,
              `/enhanced-stats/profitability/${walletAddress}?days=max`,
              `/wallet/${walletAddress}/track-status`,
              `TRPC profile.fetchTokenPnlSlow`
            ]
          };

          if (portfolioData.status === 'fulfilled') {
            result.portfolio = portfolioData.value.data;
          } else {
            console.log(`‚ö†Ô∏è [COMPLETE] Portfolio failed: ${portfolioData.reason}`);
            result.portfolio_error = portfolioData.reason.message;
          }

          if (statsAggregatedData.status === 'fulfilled') {
            result.stats_aggregated = statsAggregatedData.value.data;
            result.period_stats = calculatePeriodStats(statsAggregatedData.value, 'all_time');
          } else {
            console.log(`‚ö†Ô∏è [COMPLETE] Stats Aggregated failed: ${statsAggregatedData.reason}`);
            result.stats_aggregated_error = statsAggregatedData.reason.message;
          }

          if (profitabilityData.status === 'fulfilled') {
            result.profitability = profitabilityData.value.data;
          } else {
            console.log(`‚ö†Ô∏è [COMPLETE] Profitability failed: ${profitabilityData.reason}`);
            result.profitability_error = profitabilityData.reason.message;
          }

          if (trackStatusData.status === 'fulfilled') {
            result.track_status = trackStatusData.value.data;
          } else {
            console.log(`‚ö†Ô∏è [COMPLETE] Track Status failed: ${trackStatusData.reason}`);
            result.track_status_error = trackStatusData.reason.message;
          }

          // Ajouter les donn√©es TRPC tokens-pnl
          if (tokensPnlData.status === 'fulfilled') {
            // Enrichir les tokens TRPC avec Geckoterminal (limit√© √† 5 pour √©viter timeout)
            let enrichedTokens = [...(tokensPnlData.value.tokens || [])]; // Copie de l'array original
            let actuallyEnrichedCount = 0;
            
            if (enrichedTokens.length > 0) {
              console.log(`üîÑ [COMPLETE] Enrichissement Gecko de ${enrichedTokens.length} tokens TRPC (tous les tokens)`);
              
              // Pr√©parer TOUS les tokens √† enrichir
              const tokensToEnrich = enrichedTokens.filter(token => token.token_address);
              
              // Enrichir en parall√®le avec Promise.all
              const enrichmentPromises = tokensToEnrich.map(async (token, index) => {
                try {
                  const tokenToEnrich = {
                    token_address: token.token_address,
                    symbol: token.token_symbol,
                    name: token.token_name,
                    ...token
                  };
                  const enrichedToken = await enrichTokenWithGecko(tokenToEnrich);
                  
                  // V√©rifier si le token a √©t√© enrichi (si il a des donn√©es Gecko)
                  if (enrichedToken.gecko_price_usd) {
                    console.log(`‚úÖ [COMPLETE] Token ${index+1}/${tokensToEnrich.length} enrichi: ${token.token_symbol} - Prix: $${enrichedToken.gecko_price_usd}`);
                    return { enriched: enrichedToken, success: true };
                  } else {
                    console.log(`‚ö†Ô∏è [COMPLETE] Token ${index+1}/${tokensToEnrich.length} non enrichi: ${token.token_symbol}`);
                    return { enriched: enrichedToken, success: false };
                  }
                } catch (enrichError) {
                  console.log(`‚ö†Ô∏è [COMPLETE] Erreur enrichissement token ${index}: ${enrichError.message}`);
                  return { enriched: token, success: false };
                }
              });
              
              // Attendre tous les enrichissements
              const enrichmentResults = await Promise.all(enrichmentPromises);
              
              // Appliquer les r√©sultats
              enrichmentResults.forEach((result, index) => {
                enrichedTokens[index] = result.enriched;
                if (result.success) {
                  actuallyEnrichedCount++;
                }
              });
              
              // Persister les tokens enrichis en base de donn√©es
              try {
                console.log(`üíæ [COMPLETE] Persistance de ${enrichedTokens.length} tokens en DB`);
                const persistResult = await persistEnrichedTokens(walletAddress, enrichedTokens);
                if (persistResult.success) {
                  console.log(`‚úÖ [COMPLETE] ${persistResult.tokens_saved} tokens persist√©s (${persistResult.enriched_tokens_saved || 0} enrichis)`);
                } else {
                  console.log(`‚ö†Ô∏è [COMPLETE] Erreur persistance: ${persistResult.error}`);
                }
              } catch (persistError) {
                console.log(`‚ö†Ô∏è [COMPLETE] Erreur inattendue persistance: ${persistError.message}`);
              }
            }
            
            result.tokens_pnl = {
              source: 'TRPC_DIRECT',
              data: {
                ...tokensPnlData.value,
                tokens: enrichedTokens
              },
              total_tokens: tokensPnlData.value.total_tokens_traded || 0,
              total_pnl_usd: tokensPnlData.value.total_pnl_usd || 0,
              winrate: tokensPnlData.value.winrate || 0,
              tokens_count: tokensPnlData.value.tokens?.length || 0,
              enriched_with_gecko: true,
              enriched_tokens_count: actuallyEnrichedCount
            };
            console.log(`‚úÖ [COMPLETE] Tokens PnL TRPC: ${tokensPnlData.value.tokens?.length || 0} tokens (${actuallyEnrichedCount} enrichis avec succ√®s)`);
          } else {
            console.log(`‚ö†Ô∏è [COMPLETE] Tokens PnL TRPC failed: ${tokensPnlData.reason}`);
            result.tokens_pnl_error = tokensPnlData.reason.message;
            
            // Fallback vers l'ancienne m√©thode enhanced-stats si disponible
            if (statsAggregatedData.status === 'fulfilled' && statsAggregatedData.value.data) {
              const statsData = statsAggregatedData.value.data;
              const allTokens: any[] = [];
              
              if (statsData.top_trade_tokens && Array.isArray(statsData.top_trade_tokens)) {
                allTokens.push(...statsData.top_trade_tokens.map((token: any) => ({ ...token, category: 'top' })));
              }
              
              if (statsData.worst_trade_tokens && Array.isArray(statsData.worst_trade_tokens)) {
                allTokens.push(...statsData.worst_trade_tokens.map((token: any) => ({ ...token, category: 'worst' })));
              }
              
              if (statsData.most_traded_token) {
                const mostTradedExists = allTokens.find((t: any) => t.address === statsData.most_traded_token.address);
                if (!mostTradedExists) {
                  allTokens.push({ ...statsData.most_traded_token, category: 'most_traded' });
                }
              }
              
              const uniqueTokens = allTokens.reduce((acc: any[], token: any) => {
                const existing = acc.find((t: any) => t.address === token.address);
                if (!existing) {
                  acc.push(token);
                }
                return acc;
              }, []);
              
              uniqueTokens.sort((a: any, b: any) => (b.pnl || 0) - (a.pnl || 0));
              
              result.tokens_pnl = {
                source: 'ENHANCED_STATS_FALLBACK',
                tokens: uniqueTokens.slice(0, 10),
                total_count: uniqueTokens.length,
                summary: {
                  total_pnl: statsData.total_pnl,
                  winrate: statsData.winrate,
                  total_roi_percentage: statsData.total_roi_percentage,
                  swap_count: statsData.swap_count
                }
              };
              console.log(`üîÑ [COMPLETE] Tokens PnL fallback: ${uniqueTokens.length} tokens`);
            }
          }

          // üóÑÔ∏è PERSISTENCE AUTOMATIQUE EN BASE DE DONN√âES
          try {
            console.log(`üíæ [COMPLETE] Sauvegarde automatique des tokens en base pour ${walletAddress}`);
            
            // R√©cup√©rer les tokens depuis TRPC ou fallback avec la bonne structure
            let tokensToSave = [];
            
            // V√©rifier la structure TRPC directe (tokens-pnl endpoint)
            if (result.tokens_pnl && result.tokens_pnl.data && result.tokens_pnl.data.tokens) {
              tokensToSave = result.tokens_pnl.data.tokens;
              console.log(`üíæ [COMPLETE] Tokens TRPC directs d√©tect√©s: ${tokensToSave.length} tokens`);
            }
            // V√©rifier la structure fallback
            else if (result.tokens_pnl && result.tokens_pnl.tokens) {
              tokensToSave = result.tokens_pnl.tokens;
              console.log(`üíæ [COMPLETE] Tokens fallback d√©tect√©s: ${tokensToSave.length} tokens`);
            }
            // V√©rifier l'ancienne structure (legacy)
            else if (result.tokens_pnl && result.tokens_pnl.data && result.tokens_pnl.data.json && result.tokens_pnl.data.json.data && result.tokens_pnl.data.json.data.tokens) {
              tokensToSave = result.tokens_pnl.data.json.data.tokens;
              console.log(`üíæ [COMPLETE] Tokens legacy d√©tect√©s: ${tokensToSave.length} tokens`);
            }
            else {
              console.log(`üíæ [COMPLETE] Structure tokens_pnl:`, Object.keys(result.tokens_pnl || {}));
              console.log(`üíæ [COMPLETE] Aucune structure de tokens reconnue`);
            }
            
            if (tokensToSave.length > 0) {
              const saveTokensUrl = `${SUPABASE_FUNCTION_URL}/save-tokens-simple`;
              const saveTokensResponse = await fetch(saveTokensUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                  walletAddress: walletAddress,
                  tokensData: tokensToSave
                })
              });

              if (saveTokensResponse.ok) {
                const saveData = await saveTokensResponse.json();
                console.log(`‚úÖ [COMPLETE] Tokens sauvegard√©s: ${saveData.tokens_saved} tokens dans wallet_tokens_extended`);
                result.database_save = {
                  success: true,
                  tokens_saved: saveData.tokens_saved,
                  table: 'wallet_tokens_extended',
                  wallet_address: walletAddress,
                  timestamp: saveData.timestamp
                };
              } else {
                const errorText = await saveTokensResponse.text();
                console.log(`‚ö†Ô∏è [COMPLETE] √âchec sauvegarde tokens: ${saveTokensResponse.status} - ${errorText}`);
                result.database_save = {
                  success: false,
                  error: `HTTP ${saveTokensResponse.status}`,
                  timestamp: new Date().toISOString()
                };
              }
            } else {
              console.log(`‚ö†Ô∏è [COMPLETE] Aucun token √† sauvegarder`);
              result.database_save = {
                success: false,
                error: 'No tokens to save',
                timestamp: new Date().toISOString()
              };
            }
          } catch (saveError) {
            console.log(`‚ö†Ô∏è [COMPLETE] Erreur sauvegarde: ${saveError.message}`);
            result.database_save = {
              success: false,
              error: saveError.message,
              timestamp: new Date().toISOString()
            };
          }

          // ü§ñ ANALYSE COMPORTEMENTALE CHATGPT - COPY TRADING SOLANA
          try {
            console.log(`ü§ñ [COMPLETE] D√©marrage analyse comportementale ChatGPT pour copy trading...`);
            
            // Pr√©parer les donn√©es du wallet pour l'analyse ChatGPT
            const walletDataForAnalysis = {
              // Donn√©es principales du wallet
              wallet_address: walletAddress,
              
              // Donn√©es de tokens (priorit√© aux tokens TRPC)
              tokens: result.tokens_pnl?.data?.tokens || result.tokens_pnl?.tokens || [],
              total_tokens_traded: result.tokens_pnl?.total_tokens || result.tokens_pnl?.tokens_count || 0,
              
              // M√©triques de performance
              total_pnl_usd: result.tokens_pnl?.total_pnl_usd || result.stats_aggregated?.total_pnl || 0,
              winrate: result.tokens_pnl?.winrate || result.stats_aggregated?.winrate || 0,
              total_roi_percentage: result.tokens_pnl?.data?.total_roi_percentage || result.stats_aggregated?.total_roi_percentage || 0,
              
              // Donn√©es aggreg√©es
              stats_aggregated: result.stats_aggregated,
              profitability: result.profitability,
              period_stats: result.period_stats,
              
              // M√©tadonn√©es
              enriched_tokens_count: result.tokens_pnl?.enriched_tokens_count || 0,
              data_source: result.source,
              timestamp: result.timestamp
            };
            
            console.log(`üìä [COMPLETE] Donn√©es pr√©par√©es pour ChatGPT:`, {
              tokens_count: walletDataForAnalysis.tokens.length,
              total_pnl_usd: walletDataForAnalysis.total_pnl_usd,
              winrate: walletDataForAnalysis.winrate,
              total_trades: walletDataForAnalysis.total_tokens_traded
            });
            
            // Appel √† l'API d'analyse ChatGPT
            const analyzeWalletUrl = `${SUPABASE_FUNCTION_URL}/analyze-wallet-behavior`;
            const startAnalysisTime = Date.now();
            
            const analysisResponse = await fetch(analyzeWalletUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
              },
              body: JSON.stringify({
                walletData: walletDataForAnalysis,
                walletAddress: walletAddress
              })
            });

            const analysisTime = Date.now() - startAnalysisTime;
            
            if (analysisResponse.ok) {
              const analysisData = await analysisResponse.json();
              console.log(`‚úÖ [COMPLETE] Analyse ChatGPT r√©ussie en ${analysisTime}ms`);
              console.log(`üéØ [COMPLETE] Score copy trading: ${analysisData.copyTradingScore}/100, Recommandation: ${analysisData.recommendation}`);
              
              result.behavioral_analysis = {
                success: true,
                analysis: analysisData,
                analysis_duration_ms: analysisTime,
                analyzed_at: new Date().toISOString(),
                version: 'copy_trading_solana_v2.0'
              };
              
            } else {
              const errorText = await analysisResponse.text();
              console.log(`‚ö†Ô∏è [COMPLETE] √âchec analyse ChatGPT: ${analysisResponse.status} - ${errorText}`);
              
              result.behavioral_analysis = {
                success: false,
                error: `HTTP ${analysisResponse.status}: ${errorText}`,
                analysis_duration_ms: analysisTime,
                attempted_at: new Date().toISOString(),
                fallback_reason: 'ChatGPT API call failed'
              };
            }
            
          } catch (analysisError) {
            console.log(`‚ùå [COMPLETE] Erreur analyse ChatGPT: ${analysisError.message}`);
            result.behavioral_analysis = {
              success: false,
              error: analysisError.message,
              attempted_at: new Date().toISOString(),
              fallback_reason: 'Network or parsing error'
            };
          }

          // üìä MISE √Ä JOUR DES M√âTRIQUES WALLET SUMMARY
          try {
            console.log(`üìä [COMPLETE] Mise √† jour des m√©triques wallet summary...`);
            const summaryResult = await updateWalletSummary(walletAddress, result, supabase);
            
            if (summaryResult.success) {
              console.log(`‚úÖ [COMPLETE] M√©triques wallet sauvegard√©es avec succ√®s`);
              result.wallet_summary_update = {
                success: true,
                metrics_updated: summaryResult.data,
                updated_at: new Date().toISOString()
              };
            } else {
              console.log(`‚ö†Ô∏è [COMPLETE] √âchec mise √† jour m√©triques: ${summaryResult.error}`);
              result.wallet_summary_update = {
                success: false,
                error: summaryResult.error,
                attempted_at: new Date().toISOString()
              };
            }
          } catch (summaryError) {
            console.log(`‚ùå [COMPLETE] Erreur mise √† jour m√©triques: ${summaryError.message}`);
            result.wallet_summary_update = {
              success: false,
              error: summaryError.message,
              attempted_at: new Date().toISOString()
            };
          }

          return new Response(JSON.stringify(result), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'track-status': {
          console.log(`üîç [TRACK STATUS] R√©cup√©ration du statut de tracking pour ${walletAddress}`);
          const data = await cieloRequest(`/wallet/${walletAddress}/track-status`);
          
          return new Response(JSON.stringify({
            success: true,
            data: data.data,
            source: 'CIELO_API',
            endpoint_used: '/wallet/track-status',
            timestamp: new Date().toISOString(),
            wallet_address: walletAddress
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        case 'tokens-pnl': {
          console.log(`ü™ô [TOKENS PNL] R√©cup√©ration des tokens PnL pour ${walletAddress}`);
          
          // R√©cup√©rer les param√®tres de requ√™te (format TRPC original)
          const searchParams = new URLSearchParams(url.search);
          const page = searchParams.get('page') || '1';
          const chains = searchParams.get('chains') || '';
          const timeframe = searchParams.get('timeframe') || '';
          const sortBy = searchParams.get('sortBy') || '';
          const tokenFilter = searchParams.get('tokenFilter') || '';
          
          console.log(`üîç [TOKENS PNL] Param√®tres TRPC: page=${page}, chains="${chains}", timeframe="${timeframe}", sortBy="${sortBy}", tokenFilter="${tokenFilter}"`);
          
          // Construire la requ√™te TRPC exacte
          const trpcInput = {
            "0": {
              "json": {
                "wallet": walletAddress,
                "chains": chains,
                "timeframe": timeframe,
                "sortBy": sortBy,
                "page": page,
                "tokenFilter": tokenFilter
              }
            }
          };
          
          const encodedInput = encodeURIComponent(JSON.stringify(trpcInput));
          const trpcUrl = `https://app.cielo.finance/api/trpc/profile.fetchTokenPnlSlow?batch=1&input=${encodedInput}`;
          
          console.log(`ÔøΩ [TOKENS PNL] URL TRPC: ${trpcUrl}`);
          
          try {
            const trpcResponse = await fetch(trpcUrl, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Referer': 'https://app.cielo.finance/',
                'Origin': 'https://app.cielo.finance'
              }
            });
            
            if (!trpcResponse.ok) {
              throw new Error(`TRPC request failed: ${trpcResponse.status} ${trpcResponse.statusText}`);
            }
            
            const trpcData = await trpcResponse.json();
            console.log(`‚úÖ [TOKENS PNL] R√©ponse TRPC re√ßue`);
            
            // Extraire les donn√©es du format TRPC
            if (!trpcData[0] || !trpcData[0].result || !trpcData[0].result.data) {
              throw new Error('Format de r√©ponse TRPC invalide');
            }
            
            const tokenData = trpcData[0].result.data;
            const realTokenData = tokenData.json?.data; // CORRECTION CRITIQUE
            console.log(`üìä [TOKENS PNL] ${realTokenData?.tokens?.length || 0} tokens re√ßus`);
            console.log(`üîç [TOKENS PNL] Structure tokenData:`, Object.keys(tokenData));
            console.log(`üîç [TOKENS PNL] Structure realTokenData:`, realTokenData ? Object.keys(realTokenData) : 'null');
            console.log(`üîç [TOKENS PNL] Premier token structure:`, realTokenData?.tokens?.[0] ? Object.keys(realTokenData.tokens[0]) : 'Aucun token');
            
            // Enrichir TOUS les tokens avec Geckoterminal
            let enrichedTokens = [...(realTokenData?.tokens || [])]; // Copie de l'array original
            let actuallyEnrichedCount = 0;
            
            if (enrichedTokens.length > 0) {
              console.log(`üîÑ [TOKENS PNL] Enrichissement de ${enrichedTokens.length} tokens avec Geckoterminal`);
              
              // Pr√©parer tous les tokens √† enrichir
              const tokensToEnrich = enrichedTokens.filter(token => token.token_address);
              
              // Enrichir en parall√®le avec Promise.all (par batches pour √©viter timeout)
              const batchSize = 10; // Traiter par batches de 10 tokens
              const batches: any[] = [];
              
              for (let i = 0; i < tokensToEnrich.length; i += batchSize) {
                const batch = tokensToEnrich.slice(i, i + batchSize);
                batches.push(batch);
              }
              
              console.log(`üîÑ [TOKENS PNL] Traitement en ${batches.length} batches de ${batchSize} tokens max`);
              
              for (const [batchIndex, batch] of batches.entries()) {
                console.log(`üîÑ [TOKENS PNL] Batch ${batchIndex + 1}/${batches.length}: Enrichissement de ${batch.length} tokens`);
                
                const enrichmentPromises = batch.map(async (token, indexInBatch) => {
                  try {
                    const tokenToEnrich = {
                      token_address: token.token_address,
                      token_symbol: token.token_symbol,
                      token_name: token.token_name,
                      ...token
                    };
                    
                    const enrichedToken = await enrichTokenWithGecko(tokenToEnrich);
                    
                    const globalIndex = batchIndex * batchSize + indexInBatch;
                    
                    if (enrichedToken.gecko_price_usd) {
                      console.log(`‚úÖ [TOKENS PNL] Token ${globalIndex + 1}/${tokensToEnrich.length} enrichi: ${token.token_symbol} - Prix: $${enrichedToken.gecko_price_usd}`);
                      return { index: globalIndex, enriched: enrichedToken, success: true };
                    } else {
                      console.log(`‚ö†Ô∏è [TOKENS PNL] Token ${globalIndex + 1}/${tokensToEnrich.length} non enrichi: ${token.token_symbol}`);
                      return { index: globalIndex, enriched: enrichedToken, success: false };
                    }
                  } catch (enrichError) {
                    const globalIndex = batchIndex * batchSize + indexInBatch;
                    console.log(`‚ö†Ô∏è [TOKENS PNL] Erreur enrichissement token ${globalIndex + 1}: ${enrichError.message}`);
                    return { index: globalIndex, enriched: token, success: false };
                  }
                });
                
                // Attendre le batch complet
                const batchResults = await Promise.all(enrichmentPromises);
                
                // Appliquer les r√©sultats
                batchResults.forEach(result => {
                  const originalIndex = enrichedTokens.findIndex(t => 
                    t.token_address === tokensToEnrich[result.index].token_address
                  );
                  if (originalIndex !== -1) {
                    enrichedTokens[originalIndex] = result.enriched;
                    if (result.success) {
                      actuallyEnrichedCount++;
                    }
                  }
                });
                
                console.log(`‚úÖ [TOKENS PNL] Batch ${batchIndex + 1}/${batches.length} termin√©`);
              }
            }
            
            console.log(`‚úÖ [TOKENS PNL] Donn√©es compl√®tes r√©cup√©r√©es et enrichies (${actuallyEnrichedCount} tokens enrichis avec succ√®s)`);
            console.log(`üîç [TOKENS PNL] Structure finale enrichedTokens[0]:`, enrichedTokens[0] ? Object.keys(enrichedTokens[0]) : 'Aucun token');
            console.log(`üîç [TOKENS PNL] Premier token enrichi - gecko_price_usd:`, enrichedTokens[0]?.gecko_price_usd);
            
            // Persister les tokens enrichis en base de donn√©es
            try {
              console.log(`üíæ [TOKENS PNL] Persistance de ${enrichedTokens.length} tokens en DB`);
              const persistResult = await persistEnrichedTokens(walletAddress, enrichedTokens);
              if (persistResult.success) {
                console.log(`‚úÖ [TOKENS PNL] ${persistResult.tokens_saved} tokens persist√©s (${persistResult.enriched_tokens_saved || 0} enrichis)`);
              } else {
                console.log(`‚ö†Ô∏è [TOKENS PNL] Erreur persistance: ${persistResult.error}`);
              }
            } catch (persistError) {
              console.log(`‚ö†Ô∏è [TOKENS PNL] Erreur inattendue persistance: ${persistError.message}`);
            }
            
            // Garder seulement les donn√©es essentielles de realTokenData et les tokens enrichis
            const responseData = {
              total_pnl_usd: realTokenData.total_pnl_usd,
              total_unrealized_pnl_usd: realTokenData.total_unrealized_pnl_usd,
              winrate: realTokenData.winrate,
              total_tokens_traded: realTokenData.total_tokens_traded,
              total_roi_percentage: realTokenData.total_roi_percentage,
              total_unrealized_roi_percentage: realTokenData.total_unrealized_roi_percentage,
              combined_pnl_usd: realTokenData.combined_pnl_usd,
              combined_roi_percentage: realTokenData.combined_roi_percentage,
              combined_average_hold_time: realTokenData.combined_average_hold_time,
              combined_median_hold_time: realTokenData.combined_median_hold_time,
              tokens: enrichedTokens,  // Nos tokens enrichis
              json: {
                data: {
                  ...realTokenData,
                  tokens: enrichedTokens  // Aussi dans la structure json pour compatibilit√©
                }
              }
            };
            console.log(`üîç [TOKENS PNL] Structure response data:`, Object.keys(responseData));
            console.log(`üîç [TOKENS PNL] Response tokens count: ${responseData.tokens.length}, json tokens count: ${responseData.json.data.tokens.length}`);
            
            return new Response(JSON.stringify({
              success: true,
              data: responseData,
              source: 'CIELO_TRPC_DIRECT',
              endpoint_used: 'profile.fetchTokenPnlSlow',
              trpc_equivalent: 'profile.fetchTokenPnlSlow',
              trpc_url: trpcUrl,
              metadata: {
                wallet: walletAddress,
                parameters: { page, chains, timeframe, sortBy, tokenFilter },
                enriched_with_gecko: true,
                enriched_tokens_count: actuallyEnrichedCount,
                trpc_direct_call: true
              },
              timestamp: new Date().toISOString()
            }), {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
            
          } catch (error) {
            console.error(`‚ùå [TOKENS PNL] Erreur TRPC: ${error.message}`);
            
            // Fallback vers l'ancienne m√©thode enhanced-stats en cas d'erreur TRPC
            console.log(`üîÑ [TOKENS PNL] Fallback vers enhanced-stats...`);
            
            const fallbackEndpoint = `/enhanced-stats/aggregated/${walletAddress}?days=max`;
            const fallbackData = await cieloRequest(fallbackEndpoint);
            
            if (fallbackData?.data) {
              const statsData = fallbackData.data;
              const allTokens: any[] = [];
              
              // Extraire les tokens depuis enhanced-stats comme avant
              if (statsData.top_trade_tokens && Array.isArray(statsData.top_trade_tokens)) {
                allTokens.push(...statsData.top_trade_tokens.map((token: any) => ({ ...token, category: 'top' })));
              }
              
              if (statsData.worst_trade_tokens && Array.isArray(statsData.worst_trade_tokens)) {
                allTokens.push(...statsData.worst_trade_tokens.map((token: any) => ({ ...token, category: 'worst' })));
              }
              
              if (statsData.most_traded_token) {
                const mostTradedExists = allTokens.find((t: any) => t.address === statsData.most_traded_token.address);
                if (!mostTradedExists) {
                  allTokens.push({ ...statsData.most_traded_token, category: 'most_traded' });
                }
              }
              
              return new Response(JSON.stringify({
                success: true,
                data: {
                  tokens: allTokens,
                  total_tokens_traded: allTokens.length,
                  total_pnl_usd: statsData.total_pnl,
                  winrate: statsData.winrate,
                  total_roi_percentage: statsData.total_roi_percentage
                },
                source: 'CIELO_API_FALLBACK',
                endpoint_used: fallbackEndpoint,
                trpc_equivalent: 'profile.fetchTokenPnlSlow',
                fallback_reason: 'TRPC call failed',
                trpc_error: error.message,
                timestamp: new Date().toISOString()
              }), {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            throw error;
          }
        }

        // Nouvel endpoint pour tester l'enrichissement Geckoterminal
        if (action === 'test-gecko') {
          if (!walletAddress) {
            // Test avec un token fixe si pas d'adresse fournie
            const testToken = {
              token_address: '25PwuUsuJ4PHtZ4TCprvmrVkbNQNvYuWj1CZd2xqbonk',
              token_symbol: 'SDOG',
              token_name: 'SDOG Test'
            };
            
            console.log(`üß™ [TEST GECKO] Test avec token fixe: ${testToken.token_symbol}`);
            const enriched = await enrichTokenWithGecko(testToken);
            
            return new Response(JSON.stringify({
              success: true,
              test_type: 'fixed_token',
              original: testToken,
              enriched: enriched,
              has_price: !!enriched.gecko_price_usd,
              timestamp: new Date().toISOString()
            }), {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          } else {
            // Utiliser le walletAddress comme token_address pour test direct
            const testToken = {
              token_address: walletAddress,
              token_symbol: 'TEST',
              token_name: 'Test Token'
            };
            
            console.log(`üß™ [TEST GECKO] Test avec token custom: ${walletAddress}`);
            const enriched = await enrichTokenWithGecko(testToken);
            
            return new Response(JSON.stringify({
              success: true,
              test_type: 'custom_token',
              token_address: walletAddress,
              original: testToken,
              enriched: enriched,
              has_price: !!enriched.gecko_price_usd,
              timestamp: new Date().toISOString()
            }, null, 2), {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          }
        }

        default:
          return new Response(JSON.stringify({
            error: 'Unknown action',
            available_actions: ['portfolio', 'stats', 'stats-7d', 'profitability', 'profitability-7d', 'track-status', 'tokens-pnl', 'pnl', 'pnl-complete', 'complete', 'health'],
            example: '/cielo-api/portfolio/ABdAsGjQv1bLLvzgcqEWJmAuwNbUJyfNUausyTVe7STB'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
      }
    } catch (error) {
      console.error(`üí• [API ERROR] ${action} failed for ${walletAddress}:`, error.message);
      
      // Fallback vers les donn√©es stables
      console.log(`üîÑ [FALLBACK] Using stable data for ${walletAddress}`);
      const fallbackData = getStableWalletData(walletAddress);
      
      return new Response(JSON.stringify({
        success: false,
        error: error.message,
        fallback_data: fallbackData,
        source: 'FALLBACK_STABLE_DATA',
        timestamp: new Date().toISOString(),
        wallet_address: walletAddress
      }), {
        status: 200, // 200 car on retourne des donn√©es de fallback
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

  } catch (error) {
    console.error(`üí• [SERVER ERROR]:`, error.message);
    return new Response(JSON.stringify({
      error: 'Internal server error',
      message: error.message,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});
